<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://imalan6.github.io/atom.xml" rel="self"/>
  
  <link href="https://imalan6.github.io/"/>
  <updated>2024-02-18T09:09:06.909Z</updated>
  <id>https://imalan6.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用tushare和akshare获取股票历史行情和每日的成交明细</title>
    <link href="https://imalan6.github.io/2024/01/06/python/%E7%94%A8tushare%E5%92%8Cakshare%E8%8E%B7%E5%8F%96%E8%82%A1%E7%A5%A8%E5%8E%86%E5%8F%B2%E8%A1%8C%E6%83%85%E5%92%8C%E6%AF%8F%E6%97%A5%E7%9A%84%E6%88%90%E4%BA%A4%E6%98%8E%E7%BB%86/"/>
    <id>https://imalan6.github.io/2024/01/06/python/%E7%94%A8tushare%E5%92%8Cakshare%E8%8E%B7%E5%8F%96%E8%82%A1%E7%A5%A8%E5%8E%86%E5%8F%B2%E8%A1%8C%E6%83%85%E5%92%8C%E6%AF%8F%E6%97%A5%E7%9A%84%E6%88%90%E4%BA%A4%E6%98%8E%E7%BB%86/</id>
    <published>2024-01-06T15:16:21.000Z</published>
    <updated>2024-02-18T09:09:06.909Z</updated>
    
    <content type="html"><![CDATA[<p>朋友最近想要获取所有股票的每日逐笔成交明细用来分析，找我帮我。于是网上搜了一遍，发现免费提供这种功能的接口并不多，但也有一些。</p><p>其中，tu_share和akshare两个开源的金融工具包有类似接口，但也只能获取最近交易日的成交明细，没法获取所有的成交明细（历史+当日）。后来获取一次才发现，仅一个交易日的成交明细就高达1300多万条记录（还只是沪深A股），数据量太大了。所以，没有接口提供历史成交明细，也能理解了。</p><p>虽然没有成交明细，但可以获取历史日行情用于分析，tu_share的就可以。</p><p>tu_share有些接口需要充值获取积分才能调用，就是变相的付费接口。akshare是免费的，但只能获取最近交易日的成交明细。因此，两者综合一下，用tu_share获取历史每日行情，用akshare每天定时获取当日的成交明细。要分析历史成交明细就办不到了，只能分析以后的。</p><h4 id="一、tu-share获取股票历史日行情"><a href="#一、tu-share获取股票历史日行情" class="headerlink" title="一、tu_share获取股票历史日行情"></a>一、tu_share获取股票历史日行情</h4><p>1、tu_share介绍</p><p>tu_share是国内现有的免费数据接口中，比较好的股票&#x2F;基金数据获取方式。但新版的tushare pro对于提取数据有积分要求，具体要求详见tushare pro官网。</p><p>官方网站：<a href="https://tushare.pro/">https://tushare.pro/</a></p><p>获取股票历史日行情，需要调用 行情数据—日线行情 接口，如下：</p><p><img src="/2024/01/06/python/%E7%94%A8tushare%E5%92%8Cakshare%E8%8E%B7%E5%8F%96%E8%82%A1%E7%A5%A8%E5%8E%86%E5%8F%B2%E8%A1%8C%E6%83%85%E5%92%8C%E6%AF%8F%E6%97%A5%E7%9A%84%E6%88%90%E4%BA%A4%E6%98%8E%E7%BB%86/1708062836971.png" alt="1708062836971"></p><p>2、实现功能</p><p>这种调接口获取数据，再加工处理分析的，还是用python写比较方便快捷。同时，用之前 获取的股票列表依次批量获取。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据股票列表，开始/结束日期，获取股票成交明细</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_stock_data</span>(<span class="params">stock_list, start_date, end_date</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        df = fetch_stock_data(stock_list, start_date, end_date)</span><br><span class="line">        <span class="keyword">if</span> df <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="built_in">len</span>(df) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;查询 &#123;&#125; 数据成功，共 &#123;&#125; 条&#x27;</span>.<span class="built_in">format</span>(stock_list, <span class="built_in">len</span>(df)))</span><br><span class="line">            to_mysql(df)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">3</span>:</span><br><span class="line">                file = <span class="string">r&#x27;D:\\stock\\error.txt&#x27;</span></span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;a+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(stock_list + <span class="string">&#x27;\n&#x27;</span>)  <span class="comment"># 加\n换行显示</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;查询 &#123;&#125; 数据失败，已记录...&#x27;</span>.<span class="built_in">format</span>(stock_list))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;查询 &#123;&#125; 数据失败，共 &#123;&#125; 条&#x27;</span>.<span class="built_in">format</span>(stock_list, <span class="built_in">len</span>(df)))</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;秒后重新获取...&#x27;</span>.<span class="built_in">format</span>(count * <span class="number">5</span> + <span class="number">5</span>))</span><br><span class="line">                time.sleep(count * <span class="number">5</span> + <span class="number">5</span>)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用tu_share日行情接口获取数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_stock_data</span>(<span class="params">stock_list, start_date, end_date</span>):</span><br><span class="line">    <span class="comment"># 初始化pro接口</span></span><br><span class="line">    pro = ts.pro_api(<span class="string">&#x27;2c69591b5e3e77669c4e4269a72620****************&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 拉取数据</span></span><br><span class="line">    df = pro.daily(**&#123;</span><br><span class="line">        <span class="string">&quot;ts_code&quot;</span>: stock_list,</span><br><span class="line">        <span class="string">&quot;trade_date&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;start_date&quot;</span>: start_date,</span><br><span class="line">        <span class="string">&quot;end_date&quot;</span>: end_date,</span><br><span class="line">        <span class="string">&quot;offset&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;limit&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;, fields=[</span><br><span class="line">        <span class="string">&quot;ts_code&quot;</span>,</span><br><span class="line">        <span class="string">&quot;trade_date&quot;</span>,</span><br><span class="line">        <span class="string">&quot;open&quot;</span>,</span><br><span class="line">        <span class="string">&quot;high&quot;</span>,</span><br><span class="line">        <span class="string">&quot;low&quot;</span>,</span><br><span class="line">        <span class="string">&quot;close&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pre_close&quot;</span>,</span><br><span class="line">        <span class="string">&quot;change&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pct_chg&quot;</span>,</span><br><span class="line">        <span class="string">&quot;vol&quot;</span>,</span><br><span class="line">        <span class="string">&quot;amount&quot;</span></span><br><span class="line">    ])</span><br><span class="line">    <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure><p>保存进mysql数据库，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">to_mysql</span>(<span class="params">dataframe</span>):</span><br><span class="line">    <span class="comment"># 将数据存入数据库</span></span><br><span class="line">    engine = create_engine(<span class="string">&#x27;mysql://root:******@localhost:3306/a_stock?charset=utf8&#x27;</span>)</span><br><span class="line">    dataframe.to_sql(<span class="string">&#x27;stock_tu_daily&#x27;</span>, con=engine, if_exists=<span class="string">&#x27;append&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;写入数据库成功！&#x27;</span>)</span><br></pre></td></tr></table></figure><p>不得不说，python写数据库真是太方便了，dataframe数据格式写数据库，一个to_sql函数直接搞定！！！</p><p>4000多只股票（60&#x2F;00&#x2F;30开头的A股），从2017年1月1日 ~ 2024年1月1日，总共630多万条记录，也还好，不算多。</p><h4 id="二、akshare获取当日逐笔成交明细"><a href="#二、akshare获取当日逐笔成交明细" class="headerlink" title="二、akshare获取当日逐笔成交明细"></a>二、akshare获取当日逐笔成交明细</h4><p>1、akshare介绍</p><p>AKShare是基于 Python 的财经数据接口库，目的是实现对股票、期货、期权、基金、外汇、债券、指数、加密货币等金融产品的基本面数据、实时和历史行情数据、衍生数据从数据采集、数据清洗到数据落地的一套工具。akshare是完全免费的。</p><p>官方网址：<a href="https://akshare.akfamily.xyz/">https://akshare.akfamily.xyz/</a></p><p>获取股票最近交易日成交明细，需要调用 历史分笔 数据接口：</p><p><img src="/2024/01/06/python/%E7%94%A8tushare%E5%92%8Cakshare%E8%8E%B7%E5%8F%96%E8%82%A1%E7%A5%A8%E5%8E%86%E5%8F%B2%E8%A1%8C%E6%83%85%E5%92%8C%E6%AF%8F%E6%97%A5%E7%9A%84%E6%88%90%E4%BA%A4%E6%98%8E%E7%BB%86/1708065300211.png" alt="1708065300211"></p><p>2、实现功能</p><p>同样地，用之前获取的股票列表依次批量获取，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取历史成交明细数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">engine, stock_list, index</span>):</span><br><span class="line">    stock_zh_a_tick_tx_js_df = ak.stock_zh_a_tick_tx_js(symbol=stock_list[index])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;thread:&#123;&#125;, index:&#123;&#125;, code:&#123;&#125;,  number:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(threading.current_thread().name, index, stock_list[index],</span><br><span class="line">                                                   <span class="built_in">len</span>(stock_zh_a_tick_tx_js_df)))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        stock_zh_a_tick_tx_js_df.columns = [<span class="string">&#x27;trade_time&#x27;</span>, <span class="string">&#x27;trade_price&#x27;</span>, <span class="string">&#x27;change&#x27;</span>, <span class="string">&#x27;vol&#x27;</span>, <span class="string">&#x27;amount&#x27;</span>, <span class="string">&#x27;type&#x27;</span>]</span><br><span class="line">        stock_zh_a_tick_tx_js_df[<span class="string">&#x27;code&#x27;</span>] = stock_list[index][<span class="number">2</span>:]</span><br><span class="line">        stock_zh_a_tick_tx_js_df[<span class="string">&#x27;trade_date&#x27;</span>] = <span class="string">&#x27;2024-02-07&#x27;</span></span><br><span class="line"></span><br><span class="line">        stock_zh_a_tick_tx_js_df.to_sql(<span class="string">&#x27;stock_ak_trade_detail&#x27;</span>, con=engine, if_exists=<span class="string">&#x27;append&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;写入数据库成功！&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><p>因为数据量太大，最好开个线程池多线程获取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment"># 将数据存入数据库</span></span><br><span class="line">   engine = create_engine(<span class="string">&#x27;mysql://root:******@localhost:3306/a_stock?charset=utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">   stock_list = pd.read_sql(sql=<span class="string">&quot;select code, market from stock_list where market != &#x27;&#x27;&quot;</span>, con=engine)</span><br><span class="line">   stock_list = (stock_list[<span class="string">&#x27;market&#x27;</span>].<span class="built_in">str</span>.lower()).<span class="built_in">str</span>.cat(stock_list[<span class="string">&#x27;code&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程池，开50个线程</span></span><br><span class="line">   threadPool = ThreadPoolExecutor(max_workers=<span class="number">50</span>, thread_name_prefix=<span class="string">&quot;stock_&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 根据股票代码列表，循环依次获取数据</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(stock_list)):</span><br><span class="line">       threadPool.submit(get_data, engine, stock_list, i)</span><br><span class="line"></span><br><span class="line">   threadPool.shutdown(wait=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>一个交易日的成交明细数据量大概在1300万~1500万之间，耗时几十分钟。主要是接口返回数据太慢了，单次10来秒 ~ 一两分钟不等，可能跟IP访问频次有关，接口有一定限制。</p><p>现在问题来了，前期没想到数据量这么大，每日近1500万条记录，用Mysql存显然是不现实的。虽然表字段不多也不复杂，还添加了索引，几千万至上亿条记录也是没问题的。但是随着时间增长，可能再过一两周问题就出现了。得尽快考虑新的存储方式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;朋友最近想要获取所有股票的每日逐笔成交明细用来分析，找我帮我。于是网上搜了一遍，发现免费提供这种功能的接口并不多，但也有一些。&lt;/p&gt;
&lt;p&gt;其中，tu_share和akshare两个开源的金融工具包有类似接口，但也只能获取最近交易日的成交明细，没法获取所有的成交明细（历史</summary>
      
    
    
    
    <category term="python" scheme="https://imalan6.github.io/categories/python/"/>
    
    
    <category term="python" scheme="https://imalan6.github.io/tags/python/"/>
    
    <category term="爬虫" scheme="https://imalan6.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>用python爬股票列表数据</title>
    <link href="https://imalan6.github.io/2024/01/02/python/%E7%94%A8python%E7%88%AC%E8%82%A1%E7%A5%A8%E5%88%97%E8%A1%A8%E6%95%B0%E6%8D%AE/"/>
    <id>https://imalan6.github.io/2024/01/02/python/%E7%94%A8python%E7%88%AC%E8%82%A1%E7%A5%A8%E5%88%97%E8%A1%A8%E6%95%B0%E6%8D%AE/</id>
    <published>2024-01-02T05:12:33.000Z</published>
    <updated>2024-02-15T11:54:51.642Z</updated>
    
    <content type="html"><![CDATA[<p> 最近帮一个做金融的朋友爬股票数据。网上找遍了居然没有免费获取A股列表的接口，没办法只能去股票网站爬数据。</p><h3 id="一、访问目标网站"><a href="#一、访问目标网站" class="headerlink" title="一、访问目标网站"></a>一、访问目标网站</h3><p>同花顺行情中心：<a href="https://q.10jqka.com.cn/%EF%BC%8C%E6%89%93%E5%BC%80%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%EF%BC%8C%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%EF%BC%8C%E6%89%BE%E5%88%B0%E6%95%B0%E6%8D%AE%E6%89%80%E5%9C%A8%E4%BD%8D%E7%BD%AE%E3%80%82%E6%9C%89%E8%82%A1%E7%A5%A8%E5%90%8D%E7%A7%B0%EF%BC%8C%E4%BB%A3%E7%A0%81%EF%BC%8C%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7">https://q.10jqka.com.cn/，打开开发者工具，查看代码，找到数据所在位置。有股票名称，代码，相关属性</a></p><p><img src="/2024/01/02/python/%E7%94%A8python%E7%88%AC%E8%82%A1%E7%A5%A8%E5%88%97%E8%A1%A8%E6%95%B0%E6%8D%AE/image-20240215185556750.png" alt="image-20240215185556750"></p><p>但是在爬取过程中发现一个问题：<strong>程序自动打开的浏览器，程序模拟点击下一页，网页没有任何反应，一直卡住。但是手动打开网站，下一页是可以点击的</strong>。估计是网站做了反爬虫处理。</p><p>既然手动打开浏览器访问一切正常，那就换个思路：<strong>先手动打开浏览器访问，再用selenium连接已经打开的浏览器操作就可以了</strong>。</p><h3 id="二、用selenium连接已经打开的浏览器"><a href="#二、用selenium连接已经打开的浏览器" class="headerlink" title="二、用selenium连接已经打开的浏览器"></a>二、用selenium连接已经打开的浏览器</h3><p>通过 selenium 连接浏览器，需要用到两个参数 –remote-debugging-port 和 –user-data-dir </p><ul><li><code>--remote-debugging-port</code> 这个参数允许通过远程的方式连接，selenium 当然也可以。</li><li><code>--user-data-dir</code> 这个参数指定一个目录存放用户数据，在连接时也要设置，否则会失效。</li></ul><p>1、通过命令行打开浏览器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome.exe --remote-debugging-port=9222 --user-data-dir=<span class="string">&quot;C:\selenium\ChromeProfile&quot;</span></span><br></pre></td></tr></table></figure><p>2、快捷方式设置参数</p><p>用命令行打开浏览器不常用，可以在 chrome 的快捷方式上添加参数。右击快捷方式，选择属性，在目标栏后面加上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--remote-debugging-port=9222 --user-data-dir=<span class="string">&quot;C:\selenium\ChromeProfile&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/2024/01/02/python/%E7%94%A8python%E7%88%AC%E8%82%A1%E7%A5%A8%E5%88%97%E8%A1%A8%E6%95%B0%E6%8D%AE/format,png.png" alt="img"></p><p>现在，通过快捷方式直接打开浏览器也可以远程调试了。</p><p>3、selenium操作浏览器时，记得加上参数 options.add_experimental_option(“debuggerAddress”, “127.0.0.1:9222”)，关键代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selenium_url_chrome</span>(<span class="params">url, <span class="built_in">id</span>, stock_values</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 谷歌浏览器位置</span></span><br><span class="line">    chrome_location = <span class="string">r&#x27;C:\Users\admin\Downloads\chrome-win64\chrome.exe&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 谷歌浏览器驱动地址</span></span><br><span class="line">    service = Service(<span class="string">&#x27;D:\chromedriver.exe&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建option对象</span></span><br><span class="line">    options = Options()</span><br><span class="line">    <span class="comment"># 指定连接端口</span></span><br><span class="line">    options.add_experimental_option(<span class="string">&quot;debuggerAddress&quot;</span>, <span class="string">&quot;127.0.0.1:9222&quot;</span>)</span><br><span class="line">    options.binary_location = chrome_location  </span><br><span class="line">    </span><br><span class="line">    driver = webdriver.Chrome(options=options, service=service)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 访问指定的url地址</span></span><br><span class="line">    driver.get(url)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待指定元素加载成功</span></span><br><span class="line">    WebDriverWait(driver, <span class="number">10</span>).until(EC.visibility_of(driver.find_element(by=By.ID, value=<span class="string">&#x27;maincont&#x27;</span>)))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> get_data(driver, driver.page_source, <span class="built_in">id</span>, stock_values)</span><br></pre></td></tr></table></figure><p>4、解析元素，抓取数据，关键代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">driver, html_text, <span class="built_in">id</span>, stock_values</span>):</span><br><span class="line"></span><br><span class="line">    bs = BeautifulSoup(html_text, <span class="string">&quot;html.parser&quot;</span>)  <span class="comment"># 创建BeautifulSoup对象</span></span><br><span class="line">    body = bs.body  <span class="comment"># 获取body部分</span></span><br><span class="line">    data = body.find(<span class="string">&#x27;div&#x27;</span>, &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;maincont&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    tbody = data.find(<span class="string">&#x27;table&#x27;</span>)  <span class="comment"># 获取ul部分</span></span><br><span class="line">    trs = tbody.find_all(<span class="string">&#x27;tr&#x27;</span>)  <span class="comment"># 获取所有的li</span></span><br><span class="line"></span><br><span class="line">    stock_value_temp = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> trs:  <span class="comment"># 对每个li标签中的内容进行遍历</span></span><br><span class="line">        tds = tr.find_all(<span class="string">&#x27;td&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(tds) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tds[<span class="number">1</span>].text.startswith(<span class="string">&#x27;60&#x27;</span>): <span class="comment"># 代码60开头的是上海市场</span></span><br><span class="line">            market = <span class="string">&#x27;SH&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> tds[<span class="number">1</span>].text.startswith(<span class="string">&#x27;30&#x27;</span>) <span class="keyword">or</span> tds[<span class="number">1</span>].text.startswith(<span class="string">&#x27;00&#x27;</span>): <span class="comment"># 代码00、30开头的是深圳市场</span></span><br><span class="line">            market = <span class="string">&#x27;SZ&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            market = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        stock_value_temp.append((<span class="built_in">id</span>, tds[<span class="number">1</span>].text, market, tds[<span class="number">2</span>].text, tds[<span class="number">12</span>].text, tds[<span class="number">13</span>].text, <span class="string">&#x27;2024-01-02&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">        stock_values.append((<span class="built_in">id</span>, tds[<span class="number">1</span>].text, market, tds[<span class="number">2</span>].text, tds[<span class="number">12</span>].text, tds[<span class="number">13</span>].text, <span class="string">&#x27;2024-01-02&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="built_in">id</span> += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第 &#123;&#125; 页数据 &#123;&#125;：&#x27;</span>.<span class="built_in">format</span>(math.floor(<span class="built_in">id</span> / <span class="number">20</span>), stock_value_temp))</span><br><span class="line">    <span class="comment"># 写入excel表格</span></span><br><span class="line">    excel.write_excel_xlsx_append(<span class="string">&#x27;D:\\stock\\stock.xlsx&#x27;</span>, stock_value_temp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        el = driver.find_element(By.XPATH, <span class="string">&quot;//a[contains(text(),&#x27;下一页&#x27;)]&quot;</span>)</span><br><span class="line">            <span class="comment"># driver.execute_script(&quot;arguments[0].click();&quot;, el)</span></span><br><span class="line">        el.click()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">raise</span> CustomError(<span class="string">&quot;已到最后一页&quot;</span>)</span><br><span class="line"></span><br><span class="line">    WebDriverWait(driver, <span class="number">5</span>).until(EC.visibility_of(driver.find_element(by=By.ID, value=<span class="string">&#x27;maincont&#x27;</span>)))</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p>5、同时保存进数据库mysql中，关键代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert_data</span>(<span class="params">stock_values</span>):</span><br><span class="line">    <span class="comment"># 打开数据库连接</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, passwd=<span class="string">&#x27;888888&#x27;</span>, port=<span class="number">3306</span>, db=<span class="string">&#x27;a_stock&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;连接数据库成功！&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;pymysql数据库连接异常：&quot;</span>, e)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 cursor() 方法创建一个游标对象 cursor</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行sql语句</span></span><br><span class="line">        cursor.executemany(<span class="string">&#x27;INSERT INTO stock_list(id, code, market, name, pe, ltsz, date, del) values(%s, %s, %s, %s, %s, %s, %s, %s)&#x27;</span>, stock_values)</span><br><span class="line">        <span class="comment"># 提交到数据库执行</span></span><br><span class="line">        db.commit()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;数据插入数据库成功！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;数据库异常：&quot;</span>, e)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 最近帮一个做金融的朋友爬股票数据。网上找遍了居然没有免费获取A股列表的接口，没办法只能去股票网站爬数据。&lt;/p&gt;
&lt;h3 id=&quot;一、访问目标网站&quot;&gt;&lt;a href=&quot;#一、访问目标网站&quot; class=&quot;headerlink&quot; title=&quot;一、访问目标网站&quot;&gt;&lt;/a&gt;一</summary>
      
    
    
    
    <category term="python" scheme="https://imalan6.github.io/categories/python/"/>
    
    
    <category term="python" scheme="https://imalan6.github.io/tags/python/"/>
    
    <category term="爬虫" scheme="https://imalan6.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>用python爬china_radio音频</title>
    <link href="https://imalan6.github.io/2023/03/02/python/%E7%94%A8python%E7%88%ACchina_radio%E9%9F%B3%E9%A2%91/"/>
    <id>https://imalan6.github.io/2023/03/02/python/%E7%94%A8python%E7%88%ACchina_radio%E9%9F%B3%E9%A2%91/</id>
    <published>2023-03-02T05:12:33.000Z</published>
    <updated>2024-02-15T11:30:02.121Z</updated>
    
    <content type="html"><![CDATA[<p> 最近练英语听力，感觉china_radio的roundtable圆桌会议节目不错，但是音频没法下载，于是准备爬虫获取。</p><p>1、音频网址：<a href="https://chinaplus.cri.cn/podcast/list/10">https://chinaplus.cri.cn/podcast/list/10</a> ，打开chrome开发者工具查看html代码，找到音频链接。这个还是比较简单，没有动态加载，直接就有mp3链接。</p><p><img src="/2023/03/02/python/%E7%94%A8python%E7%88%ACchina_radio%E9%9F%B3%E9%A2%91/1707986547580.png" alt="1707986547580"></p><p>2、准备写抓取代码。由于页面每次显示10条，需要点击下方的more按钮，才能继续加载。于是采用selenium模拟手动点击按钮（喜欢用模拟手动操作网页，可以避免很多反爬虫）。需要先安装selenium模拟操作网页环境，见文章 </p><p>模拟点击页面关键代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_html_by_selenium_chrome</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="comment"># 谷歌浏览器位置</span></span><br><span class="line">    chrome_location = <span class="string">r&#x27;C:\Users\admin\Downloads\chrome-win64\chrome.exe&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 谷歌浏览器驱动地址</span></span><br><span class="line">    service = Service(<span class="string">&#x27;D:\chromedriver.exe&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    options = Options()</span><br><span class="line">    options.binary_location = chrome_location  <span class="comment"># 指定chrome的路径</span></span><br><span class="line">    options.add_argument(<span class="string">&#x27;–-incognito&#x27;</span>)</span><br><span class="line">    options.add_argument(<span class="string">&#x27;--disable-infobars&#x27;</span>)</span><br><span class="line">    options.add_argument(<span class="string">&#x27;--start-maximized&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个浏览器对象</span></span><br><span class="line">    driver = webdriver.Chrome(options=options, service=service)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 访问指定的url地址</span></span><br><span class="line">    driver.get(url)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待指定id元素加载完成，表示网页内容加载完成    </span></span><br><span class="line">    WebDriverWait(driver, <span class="number">10</span>).until(EC.visibility_of(driver.find_element(by=By.ID, value=<span class="string">&#x27;js-podcastList-right-latestEpisodes&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 循环点击加载更多按钮，每次加载10条，想抓取多少，就循环多少次</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 获取more元素</span></span><br><span class="line">        el = driver.find_element(By.XPATH, <span class="string">&quot;//span[contains(text(),&#x27;Load more&#x27;)]&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># js模拟点击，selenium原生点击不成功</span></span><br><span class="line">        driver.execute_script(<span class="string">&quot;arguments[0].click();&quot;</span>, el)</span><br><span class="line"></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> driver.page_source</span><br></pre></td></tr></table></figure><p>采用原生的BeautifulSoup解析页面，获取音频关键代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse_html</span>(<span class="params">html_text</span>):</span><br><span class="line">    final = []</span><br><span class="line">    bs = BeautifulSoup(html_text, <span class="string">&quot;html.parser&quot;</span>)  <span class="comment"># 创建BeautifulSoup对象</span></span><br><span class="line">    body = bs.body  <span class="comment"># 获取body部分</span></span><br><span class="line">    data = body.find(<span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">                     &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;js-podcastList-right-latestEpisodes&#x27;</span>&#125;)  <span class="comment"># 找到id为js-podcastList-right-latestEpisodes的div</span></span><br><span class="line">    ul = data.find(<span class="string">&#x27;ul&#x27;</span>)  <span class="comment"># 获取ul部分</span></span><br><span class="line">    li = ul.find_all(<span class="string">&#x27;li&#x27;</span>)  <span class="comment"># 获取所有的li</span></span><br><span class="line"></span><br><span class="line">    store_res.mkdir(<span class="string">&#x27;D:\\&#x27;</span>, <span class="string">&#x27;china_radio&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> day <span class="keyword">in</span> li:  <span class="comment"># 对每个li标签中的内容进行遍历</span></span><br><span class="line"></span><br><span class="line">        date = day.find(<span class="string">&#x27;span&#x27;</span>, &#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;js-latestEpisodes-item-time&#x27;</span>&#125;)  <span class="comment"># 获取日期</span></span><br><span class="line">        store_res.mkdir(<span class="string">&#x27;D:\\china_radio\\&#x27;</span>, date.text) <span class="comment"># 按日期建文件夹</span></span><br><span class="line"></span><br><span class="line">        play_div = day.find(<span class="string">&#x27;div&#x27;</span>, &#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;js-latestEpisodes-item-playBtn play&#x27;</span>&#125;)</span><br><span class="line">        mp3_file = play_div.get(<span class="string">&#x27;data-url&#x27;</span>)  <span class="comment"># 获取音频</span></span><br><span class="line">        <span class="built_in">print</span>(mp3_file)</span><br><span class="line"></span><br><span class="line">        introduction = day.find(<span class="string">&#x27;p&#x27;</span>, &#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;js-latestEpisodes-item-info&#x27;</span>&#125;)  <span class="comment"># 获取介绍</span></span><br><span class="line"><span class="comment"># 音频介绍存入文件中</span></span><br><span class="line">        store_res.create_txt_file(<span class="string">&#x27;introduction&#x27;</span>, <span class="string">&#x27;D:\\china_radio\\&#x27;</span> + date.text, introduction.contents[<span class="number">0</span>].text)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 最近练英语听力，感觉china_radio的roundtable圆桌会议节目不错，但是音频没法下载，于是准备爬虫获取。&lt;/p&gt;
&lt;p&gt;1、音频网址：&lt;a href=&quot;https://chinaplus.cri.cn/podcast/list/10&quot;&gt;https://chi</summary>
      
    
    
    
    <category term="python" scheme="https://imalan6.github.io/categories/python/"/>
    
    
    <category term="python" scheme="https://imalan6.github.io/tags/python/"/>
    
    <category term="爬虫" scheme="https://imalan6.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>kafka集群部署（无zookeep方式）</title>
    <link href="https://imalan6.github.io/2022/11/18/kafka/kafka%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
    <id>https://imalan6.github.io/2022/11/18/kafka/kafka%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</id>
    <published>2022-11-18T14:26:17.000Z</published>
    <updated>2024-02-14T12:11:38.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kafka部署"><a href="#kafka部署" class="headerlink" title="kafka部署"></a>kafka部署</h2><h4 id="docker安装kafka集群"><a href="#docker安装kafka集群" class="headerlink" title="docker安装kafka集群"></a>docker安装kafka集群</h4><h5 id="1、docker-compose-安装带kafka-ui的kafka集群"><a href="#1、docker-compose-安装带kafka-ui的kafka集群" class="headerlink" title="1、docker-compose 安装带kafka-ui的kafka集群"></a>1、docker-compose 安装带kafka-ui的kafka集群</h5><p>kafka2.8版本以后可以采用kraft协议，不再需要zookeeper。<br>安装kafka-3.3.1（不带zookeeper版本）的集群。仅需将下面配置中的192.168.101.103 改为自己本机的ip即可。docker-compose-kafka-cluster.yml配置文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  #kafka可视化工具</span><br><span class="line">  kafka-ui:</span><br><span class="line">    container_name: kafka-ui</span><br><span class="line">    image: provectuslabs/kafka-ui:latest</span><br><span class="line">    ports:</span><br><span class="line">      - 8989:8080</span><br><span class="line">    depends_on:</span><br><span class="line">      - kafka1</span><br><span class="line">      - kafka2</span><br><span class="line">      - kafka3</span><br><span class="line">    environment:</span><br><span class="line">      - KAFKA_CLUSTERS_0_NAME=kafkaCluster</span><br><span class="line">      - KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=192.168.101.103:9192,192.168.101.103:9292,192.168.101.103:9392</span><br><span class="line">      - DYNAMIC_CONFIG_ENABLED=true</span><br><span class="line">    networks:</span><br><span class="line">      - mynetwork</span><br><span class="line"></span><br><span class="line">  # kafka集群</span><br><span class="line">  kafka1:</span><br><span class="line">    image: &#x27;bitnami/kafka:3.3.1&#x27;</span><br><span class="line">    container_name: kafka1</span><br><span class="line">    user: root</span><br><span class="line">    ports:</span><br><span class="line">      - 9192:9092</span><br><span class="line">      - 9193:9093</span><br><span class="line">    environment:</span><br><span class="line">      ### 通用配置</span><br><span class="line">      # 允许使用kraft，即Kafka替代Zookeeper</span><br><span class="line">      - KAFKA_ENABLE_KRAFT=yes</span><br><span class="line">      # kafka角色，做broker，也要做controller</span><br><span class="line">      - KAFKA_CFG_PROCESS_ROLES=broker,controller</span><br><span class="line">      # 指定供外部使用的控制类请求信息</span><br><span class="line">      - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER</span><br><span class="line">      # 定义kafka服务端socket监听端口</span><br><span class="line">      - KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093</span><br><span class="line">      # 定义安全协议</span><br><span class="line">      - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT</span><br><span class="line">      # 使用Kafka时的集群id，集群内的Kafka都要用这个id做初始化，生成一个UUID即可</span><br><span class="line">      - KAFKA_KRAFT_CLUSTER_ID=LelM2dIFQkiUFvXCEcqRWA</span><br><span class="line">      # 集群地址</span><br><span class="line">      - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=1@kafka1:9093,2@kafka2:9093,3@kafka3:9093</span><br><span class="line">      # 允许使用PLAINTEXT监听器，默认false，不建议在生产环境使用</span><br><span class="line">      - ALLOW_PLAINTEXT_LISTENER=yes</span><br><span class="line">      # 设置broker最大内存，和初始内存</span><br><span class="line">      - KAFKA_HEAP_OPTS=-Xmx512M -Xms256M</span><br><span class="line">      # 允许自动创建主题</span><br><span class="line">      - KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE=true</span><br><span class="line">      # 消息保留时长（毫秒），保留7天</span><br><span class="line">      - KAFKA_LOG_RETENTION_MS=604800000</span><br><span class="line">      ### broker配置</span><br><span class="line">      # 定义外网访问地址（宿主机ip地址和端口）</span><br><span class="line">      - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://192.168.101.103:9192</span><br><span class="line">      # broker.id，必须唯一</span><br><span class="line">      - KAFKA_BROKER_ID=1</span><br><span class="line">    volumes:</span><br><span class="line">      - /data/bitnami/kafka1:/bitnami/kafka</span><br><span class="line">    networks:</span><br><span class="line">      - mynetwork</span><br><span class="line">  kafka2:</span><br><span class="line">    image: &#x27;bitnami/kafka:3.3.1&#x27;</span><br><span class="line">    container_name: kafka2</span><br><span class="line">    user: root</span><br><span class="line">    ports:</span><br><span class="line">      - 9292:9092</span><br><span class="line">      - 9293:9093</span><br><span class="line">    environment:</span><br><span class="line">      ### 通用配置</span><br><span class="line">      # 允许使用kraft，即Kafka替代Zookeeper</span><br><span class="line">      - KAFKA_ENABLE_KRAFT=yes</span><br><span class="line">      # kafka角色，做broker，也要做controller</span><br><span class="line">      - KAFKA_CFG_PROCESS_ROLES=broker,controller</span><br><span class="line">      # 指定供外部使用的控制类请求信息</span><br><span class="line">      - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER</span><br><span class="line">      # 定义kafka服务端socket监听端口</span><br><span class="line">      - KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093</span><br><span class="line">      # 定义安全协议</span><br><span class="line">      - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT</span><br><span class="line">      # 使用Kafka时的集群id，集群内的Kafka都要用这个id做初始化，生成一个UUID即可</span><br><span class="line">      - KAFKA_KRAFT_CLUSTER_ID=LelM2dIFQkiUFvXCEcqRWA</span><br><span class="line">      # 集群地址</span><br><span class="line">      - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=1@kafka1:9093,2@kafka2:9093,3@kafka3:9093</span><br><span class="line">      # 允许使用PLAINTEXT监听器，默认false，不建议在生产环境使用</span><br><span class="line">      - ALLOW_PLAINTEXT_LISTENER=yes</span><br><span class="line">      # 设置broker最大内存，和初始内存</span><br><span class="line">      - KAFKA_HEAP_OPTS=-Xmx512M -Xms256M</span><br><span class="line">      # 允许自动创建主题</span><br><span class="line">      - KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE=true</span><br><span class="line">      # 消息保留时长（毫秒），保留7天</span><br><span class="line">      - KAFKA_LOG_RETENTION_MS=604800000</span><br><span class="line">      ### broker配置</span><br><span class="line">      # 定义外网访问地址（宿主机ip地址和端口）</span><br><span class="line">      - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://192.168.101.103:9292</span><br><span class="line">      # broker.id，必须唯一</span><br><span class="line">      - KAFKA_BROKER_ID=2</span><br><span class="line">    volumes:</span><br><span class="line">      - /data/bitnami/kafka2:/bitnami/kafka</span><br><span class="line">    networks:</span><br><span class="line">      - mynetwork</span><br><span class="line">  kafka3:</span><br><span class="line">    image: &#x27;bitnami/kafka:3.3.1&#x27;</span><br><span class="line">    container_name: kafka3</span><br><span class="line">    user: root</span><br><span class="line">    ports:</span><br><span class="line">      - 9392:9092</span><br><span class="line">      - 9393:9093</span><br><span class="line">    environment:</span><br><span class="line">      ### 通用配置</span><br><span class="line">      # 允许使用kraft，即Kafka替代Zookeeper</span><br><span class="line">      - KAFKA_ENABLE_KRAFT=yes</span><br><span class="line">      # kafka角色，做broker，也要做controller</span><br><span class="line">      - KAFKA_CFG_PROCESS_ROLES=broker,controller</span><br><span class="line">      # 指定供外部使用的控制类请求信息</span><br><span class="line">      - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER</span><br><span class="line">      # 定义kafka服务端socket监听端口</span><br><span class="line">      - KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093</span><br><span class="line">      # 定义安全协议</span><br><span class="line">      - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT</span><br><span class="line">      # 使用Kafka时的集群id，集群内的Kafka都要用这个id做初始化，生成一个UUID即可</span><br><span class="line">      - KAFKA_KRAFT_CLUSTER_ID=LelM2dIFQkiUFvXCEcqRWA</span><br><span class="line">      # 集群地址</span><br><span class="line">      - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=1@kafka1:9093,2@kafka2:9093,3@kafka3:9093</span><br><span class="line">      # 允许使用PLAINTEXT监听器，默认false，不建议在生产环境使用</span><br><span class="line">      - ALLOW_PLAINTEXT_LISTENER=yes</span><br><span class="line">      # 设置broker最大内存，和初始内存</span><br><span class="line">      - KAFKA_HEAP_OPTS=-Xmx512M -Xms256M</span><br><span class="line">      # 允许自动创建主题</span><br><span class="line">      - KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE=true</span><br><span class="line">      # 消息保留时长（毫秒），保留7天</span><br><span class="line">      - KAFKA_LOG_RETENTION_MS=604800000</span><br><span class="line">      ### broker配置</span><br><span class="line">      # 定义外网访问地址（宿主机ip地址和端口）</span><br><span class="line">      - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://192.168.101.103:9392</span><br><span class="line">      # broker.id，必须唯一</span><br><span class="line">      - KAFKA_BROKER_ID=3</span><br><span class="line">    volumes:</span><br><span class="line">      - /data/bitnami/kafka3:/bitnami/kafka</span><br><span class="line">    networks:</span><br><span class="line">      - mynetwork</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  mynetwork:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure><p>执行命令，启动容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f docker-compose-kafka-cluster.yml up -d</span><br></pre></td></tr></table></figure><h5 id="2、安装滴滴开源Kafka-UI管理工具knowstreaming"><a href="#2、安装滴滴开源Kafka-UI管理工具knowstreaming" class="headerlink" title="2、安装滴滴开源Kafka UI管理工具knowstreaming"></a>2、安装滴滴开源Kafka UI管理工具knowstreaming</h5><p><a href="https://doc.knowstreaming.com/">https://doc.knowstreaming.com/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;kafka部署&quot;&gt;&lt;a href=&quot;#kafka部署&quot; class=&quot;headerlink&quot; title=&quot;kafka部署&quot;&gt;&lt;/a&gt;kafka部署&lt;/h2&gt;&lt;h4 id=&quot;docker安装kafka集群&quot;&gt;&lt;a href=&quot;#docker安装kafka集群&quot; c</summary>
      
    
    
    
    <category term="docker" scheme="https://imalan6.github.io/categories/docker/"/>
    
    
    <category term="kafka" scheme="https://imalan6.github.io/tags/kafka/"/>
    
    <category term="docker" scheme="https://imalan6.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>kafka数据可靠性</title>
    <link href="https://imalan6.github.io/2022/11/10/kafka/kafka%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7/"/>
    <id>https://imalan6.github.io/2022/11/10/kafka/kafka%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7/</id>
    <published>2022-11-10T15:12:33.000Z</published>
    <updated>2024-02-18T09:08:52.995Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><p>Kafka有两个很重要的配置参数：acks 与 min.insync.replicas 。其中，acks 是producer的配置参数，而 min.insync.replicas 是broker端的配置参数。这两个参数对于生产者发送数据的可靠性起了很大的作用。</p><h3 id="kafka-分区副本"><a href="#kafka-分区副本" class="headerlink" title="kafka 分区副本"></a>kafka 分区副本</h3><p>kafka 的topic是可以分区的，并且可以为分区配置多个副本，改配置可以通过 replication.factor 参数实现。 Kafka中的分区副本包括两种类型：领导者副本（Leader Replica）和追随者副本（Follower Replica)，每个分区在创建时都要选举一个副本作为领导者副本，其余的副本自动变为追随者副本。</p><p>在Kafka中，追随者副本是不对外提供服务的，也就是说，追随者副本不能响应消费者和生产者的读写请求。所有的请求都必须由领导者副本来处理。换句话说，所有的读写请求都必须发往领导者副本所在的Broker，由该 Broker 负责处理。 追随者副本不处理客户端请求，它唯一的任务就是从领导者副本异步拉取消息，并写入到自己的提交日志中，从而实现与领导者副本的同步。</p><p>Kafka默认的副本因子是3，即每个分区只有1个leader副本和2个follower副本。具体如下图所示：<br><img src="/2022/11/10/kafka/kafka%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7/v2-5eb37b02966e11f1d6a2c6a8e1ecc9b9_720w-1704100255162-3-1704100402093-20.webp" alt="img"></p><p>上面提到生产者客户端仅写入Leader broker，跟随者异步复制数据。由于Kafka是一个分布式系统，必然会存在与 Leader 不能实时同步的风险，所以需要一种方法来判断这些追随者是否跟上了领导者的步伐，即追随者是否同步了最新的数据。换句话说，Kafka 要明确地告诉我们，追随者副本到底在什么条件下才算与 Leader 同步？这就是下面所要说的ISR同步副本机制。</p><h2 id="同步副本-In-sync-replicas"><a href="#同步副本-In-sync-replicas" class="headerlink" title="同步副本(In-sync replicas)"></a>同步副本(In-sync replicas)</h2><p>In-sync replica (ISR) 称之为同步副本，ISR中的副本都是与Leader进行同步的副本，所以不在该列表的 follower 会被认为与 Leader 是不同步的。那么，ISR中存在是什么副本呢？首先可以明确的是：Leader副本总是存在于ISR中。而 follower 副本是否在ISR中，取决于该follower副本是否与Leader副本保持了“同步”。</p><blockquote><p>对于”follower副本是否与Leader副本保持了同步”的理解如下：<br>1）上面所说的同步不是指完全的同步，即并不是说一旦follower副本同步滞后与Leader副本，就会被踢出ISR列表。<br>2）Kafka的broker端有一个参数<code>replica.lag.time.max.ms</code>, 该参数表示follower副本滞后与Leader副本的最长时间间隔，默认是10秒. 这就意味着，只要follower副本落后于leader副本的时间间隔不超过10秒，就可以认为该follower副本与leader副本是同步的，所以哪怕当前follower副本落后于Leader副本几条消息，只要在10秒之内赶上Leader副本，就不会被踢出出局。<br>3）如果follower副本被踢出ISR列表，等到该副本追上了Leader副本的进度，该副本会被再次加入到ISR列表中，所以ISR是一个动态列表，并不是静态不变的。<br><img src="/2022/11/10/kafka/kafka%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7/v2-a6bce3e6b3b2830e654a36342206d410_720w.png" alt="img"></p></blockquote><p>如上图所示：Broker3 上的 partition1 副本超过了规定时间，未与 Leader 副本同步，所以被踢出ISR列表，此时的ISR为[1,3]。</p><h2 id="acks确认机制"><a href="#acks确认机制" class="headerlink" title="acks确认机制"></a>acks确认机制</h2><p>acks 参数指定了必须要有多少个分区副本收到消息，生产者才认为该消息是写入成功的，这个参数对于消息是否丢失起着重要作用，该参数的配置具体如下：</p><ul><li>acks &#x3D; 0，表示生产者在成功写入消息之前不会等待任何来自服务器的响应。换句话说，一旦出现了问题导致服务器没有收到消息，那么生产者就无从得知，消息也就丢失了。该配置由于不需要等到服务器的响应，所以可以最大速度发送消息，达到很高的吞吐量。</li></ul><p><img src="/2022/11/10/kafka/kafka%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7/v2-55567db873e4ffef10dc710567e24131_720w.png" alt="img"></p><ul><li>acks &#x3D; 1，表示只要集群的leader分区副本接收到了消息，就会向生产者发送一个成功响应的ack，此时生产者接收到 ack 之后就可以认为该消息是写入成功的。如果消息无法写入 leader 分区副本（比如网络原因、leader 节点崩溃），生产者会收到一个错误响应。当生产者接收到该错误响应之后，为了避免数据丢失，会重新发送数据。<br>注意：如果生产者收到了错误响应，即便是重新发消息，还是会有可能出现丢数据的现象。比如，如果一个没有收到消息的节点成为了新的Leader，消息就可能丢失。</li></ul><p><img src="/2022/11/10/kafka/kafka%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7/v2-d84609c80826c20bcec9822b59a40709_720w.png" alt="img"></p><ul><li>acks &#x3D; all，表示只有所有参与复制的节点（ISR列表的副本）全部收到消息后，生产者才会接收到来自服务器的 ack 响应。这种模式是最高级别的，也是最安全的，可以确保不止一个Broker接收到了消息。但该模式的延迟很高。</li></ul><p><img src="/2022/11/10/kafka/kafka%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7/v2-54d2a176d9dc727f38982176327c7237_720w.webp" alt="img"></p><h2 id="最小同步副本"><a href="#最小同步副本" class="headerlink" title="最小同步副本"></a>最小同步副本</h2><p>上面提到，当acks &#x3D; all时，需要所有的副本都同步了才会发送成功响应到生产者。其实这里面存在一个问题：如果Leader副本是唯一的同步副本时，此时相当于acks &#x3D; 1，所以也是不安全的。</p><p>Kafka 的 Broker 端提供了一个参数 min.insync.replicas，该参数控制的是消息至少被写入到多少个副本才算是”真正写入”。该值默认值为1，生产环境设定为一个大于1的值可以提升消息数据可靠性。如果同步副本的数量低于该配置值，生产者会收到错误响应，可以确保消息不丢失。</p><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景 1"></a>场景 1</h3><p>如下图，当 min.insync.replicas &#x3D; 2 且 acks &#x3D; all 时，如果此时ISR列表只有[1,2],3被踢出ISR列表，只需要保证两个副本同步了，生产者就会收到成功响应.</p><p><img src="/2022/11/10/kafka/kafka%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7/v2-0087ef0495ff85224451a849eb1c79aa_720w.webp" alt="img"></p><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景 2"></a>场景 2</h3><p>如下图，当 min.insync.replicas &#x3D; 2，如果此时ISR列表只有 [1]，而 2 和 3 被踢出ISR列表：那么，当 acks &#x3D; all 时，则不能成功写入数据；当 acks &#x3D; 0 或者 acks &#x3D; 1 可以成功写入数据。</p><p><img src="/2022/11/10/kafka/kafka%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7/v2-643579cef34f061534472f4249d8ab07_720w.png" alt="img"></p><h3 id="场景-3"><a href="#场景-3" class="headerlink" title="场景 3"></a>场景 3</h3><p>如果 acks &#x3D; all 且 min.insync.replicas &#x3D; 2，此时ISR列表为[1,2,3]，那么还是会等到所有的同步副本都同步了消息，才会向生产者发送成功响应的ack。因为 min.insync.replicas &#x3D; 2 只是一个最低限制，即同步副本少于该配置值，则会抛异常；而 acks &#x3D; all，是需要保证所有的ISR列表的副本都同步了才可以发送成功响应。这种情况是很容易引起误解的。如下图所示：</p><p><img src="/2022/11/10/kafka/kafka%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7/v2-04ebf9e3f84be19871ec66be59d6ff2e_720w.png" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>acks &#x3D; 0 时，生产者在成功写入消息之前不会等待任何来自服务器的响应。</p><p>acks &#x3D; 1 时，只要集群的leader分区副本接收到了消息，就会向生产者发送一个成功响应的ack。</p><p>acks &#x3D; all 时，只有所有参与复制的节点(ISR列表的副本)全部收到消息时，生产者才会接收到来自服务器的响应，此时如果ISR同步副本的个数小于<code>min.insync.replicas</code>的值，消息不会被写入。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;配置参数&quot;&gt;&lt;a href=&quot;#配置参数&quot; class=&quot;headerlink&quot; title=&quot;配置参数&quot;&gt;&lt;/a&gt;配置参数&lt;/h3&gt;&lt;p&gt;Kafka有两个很重要的配置参数：acks 与 min.insync.replicas 。其中，acks 是producer</summary>
      
    
    
    
    <category term="消息中间件" scheme="https://imalan6.github.io/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="kafka" scheme="https://imalan6.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Nginx反向代理集群部署</title>
    <link href="https://imalan6.github.io/2021/06/22/nginx/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
    <id>https://imalan6.github.io/2021/06/22/nginx/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</id>
    <published>2021-06-22T08:23:12.000Z</published>
    <updated>2024-02-14T12:06:55.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx反向代理集群部署"><a href="#Nginx反向代理集群部署" class="headerlink" title="Nginx反向代理集群部署"></a>Nginx反向代理集群部署</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p><code>Nginx</code>是一款非常优秀的反向代理工具，支持请求分发，负载均衡，以及缓存等。在请求处理上，<code>Nginx</code>采用<code>epoll</code>模型，这是一种基于事件监听的模型，因而其具备非常高效的请求处理效率，单机并发能力能够达到百万。<code>Nginx</code>接收到的请求可以通过负载均衡策略分发到其下一级应用服务器。对于一些特大型的网站，单机的<code>Nginx</code>并发能力是有限的，而<code>Nginx</code>本身并不支持集群模式，因而对<code>Nginx</code>的横向扩展显得尤为重要。</p><h4 id="Keepalived"><a href="#Keepalived" class="headerlink" title="Keepalived"></a>Keepalived</h4><p><code>Keepalived</code>是一款服务器状态检测和故障切换的工具。在其配置文件中，可以配置主备服务器和该服务器的状态检测请求。<code>Keepalived</code>起初是专为<code>LVS</code>负载均衡软件设计的，用来管理并监控<code>LVS</code>集群系统中各个服务节点的状态，后来又加入了可以实现高可用的<code>VRRP</code>功能。因此，<code>Keepalived</code>除了能够管理<code>LVS</code>软件外，还可以用于解决其他服务的高可用解决方案。</p><p><code>Keepalived</code>主要是通过<code>VRRP</code>协议实现高可用功能的。<code>VRRP</code>是<code>Virtual Router Redundancy Protocol</code>（虚拟路由冗余协议）的缩写，<code>VRRP</code>出现的目的就是为了解决静态路由的单点故障问题，它能保证当个别节点宕机时，整个网络可以不间断地运行。所以，<code>Keepalived</code>一方面具有配置管理<code>LVS</code>的功能，同时还具有对<code>LVS</code>下面节点进行健康检查的功能，另一方面也可以实现系统网络服务的高可用功能。</p><p><code>Keepalived</code>的高可用服务的故障切换转移功能，是通过<code>VRRP</code>来实现的。在<code>Keepalived</code>服务工作时，主<code>Master</code>节点会不断地向备节点发送（多播的方式）心跳消息，用来告诉备<code>Backup</code>节点自己还活着。当主节点发生故障时，就无法发送心跳的消息了，备节点也因此无法继续检测到来自主节点的心跳了。于是就会调用自身的接管程序，接管主节点的IP资源和服务。当主节点恢复时，备节点又会释放主节点故障时自身接管的IP资源和服务，恢复到原来的备用角色。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://i.loli.net/2021/04/11/x2mdPGtHRSofLQw.png" alt="0.png"></p><h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><h4 id="安装Keepalived-Nginx"><a href="#安装Keepalived-Nginx" class="headerlink" title="安装Keepalived+Nginx"></a>安装Keepalived+Nginx</h4><p>选择两台服务器，这里使用的是<code>centos7</code>，安装<code>Keepalived</code>和<code>Nginx</code>。</p><p>安装<code>Keepalived</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install keepalived</span><br></pre></td></tr></table></figure><p>运行<code>Keepalived</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start keepalived</span><br></pre></td></tr></table></figure><p>安装<code>Nginx</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install nginx</span><br></pre></td></tr></table></figure><p>运行<code>Nginx</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>Master服务器配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for Keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 192.168.200.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">   vrrp_skip_check_adv_addr</span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">vrrp_strict <span class="comment">#此处不注释掉，无法ping通VIP</span></span></span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">监控Nginx进程状态的脚本</span></span><br><span class="line">vrrp_script check_nginx &#123;</span><br><span class="line">    script &quot;/usr/local/server/check_nginx.sh&quot;</span><br><span class="line">    interval 2</span><br><span class="line">    weight 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER   #master为master，backup则为backup</span><br><span class="line">    interface ens33   #修改为实际的网卡</span><br><span class="line">    virtual_router_id 51   #此处MASTER和BACKUP必须一致，但是和局域网中其他的keeplived集群不能相同</span><br><span class="line">    priority 100  #数字越大，优先级越高。master高于其他</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123; #执行监控Nginx进程脚本</span><br><span class="line">check_nginx</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.0.8 #虚拟IP地址，可以配置多个</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Backup服务器配置文件(仅列不同项)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">state BACKUP  #master为master，backup则为backup </span><br><span class="line">priority 80  #数字越大，优先级越高。master高于其他</span><br></pre></td></tr></table></figure><p><code>Keepalived</code>配置文件中加了注释符号#的配置项需要修改，其余的可以不变。主要修改项如下：</p><ul><li><p><code>router_id</code> 是路由标识，在一个局域网里面应该是唯一的</p></li><li><p><code>vrrp_instance VI_1&#123;...&#125;</code>是一个<code>VRRP</code>实例，里面定义了<code>Keepalived</code>的主备状态、接口、优先级、认证和IP信息</p></li><li><p><code>state</code> 定义了VRRP的角色</p></li><li><p><code>interface</code>定义使用的接口，这里的网卡都<code>ens33</code>，根据实际填写</p></li><li><p><code>virtual_router_id</code>是虚拟路由ID标识，一组的<code>Keepalived</code>配置中主备都是一致的</p></li><li><p><code>priority</code>是优先级，数字越大，优先级越高</p></li><li><p><code>auth_type</code>是认证方式</p></li><li><p><code>auth_pass</code>是认证的密码</p></li><li><p><code>virtual_ipaddress｛...｝</code>定义虚拟IP地址，可以配置多个IP地址，这里定义为<code>192.168.0.8</code></p></li></ul><h4 id="脚本文件"><a href="#脚本文件" class="headerlink" title="脚本文件"></a>脚本文件</h4><p>注意，上面配置文件中的脚本配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">监控Nginx进程状态的脚本</span></span><br><span class="line">vrrp_script check_nginx &#123;</span><br><span class="line">    script &quot;/usr/local/server/check_nginx.sh&quot;</span><br><span class="line">    interval 2</span><br><span class="line">    weight 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的脚本文件”<code>/usr/local/server/check_nginx.sh</code>“，用于检查<code>Nginx</code>状态，内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">nginxpid=$(ps -C nginx --no-header|<span class="built_in">wc</span> -l)</span><br><span class="line"><span class="comment">#判断Nginx是否存活，如果不存活则尝试启动Nginx</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$nginxpid</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line">    systemctl start nginx</span><br><span class="line">    <span class="built_in">sleep</span> 2</span><br><span class="line">    <span class="comment">#等待2秒后，再次查看Nginx是否启动</span></span><br><span class="line">    nginxpid=$(ps -C nginx --no-header|<span class="built_in">wc</span> -l) </span><br><span class="line">    <span class="comment">#如果Nginx还是没启动，停止Keepalived，让地址漂移到其他Nginx</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$nginxpid</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line">        systemctl stop keepalived</span><br><span class="line">   <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>作用是检查<code>Nginx</code>进程是否存活，如果不存活就启动<code>Nginx</code>，并且2秒后再次检查，如果还是不存活，说明启动<code>Nginx</code>失败，然后关闭<code>Keepalived</code>服务，把虚拟地址转移给其他<code>Nginx</code>服务(<code>backup</code>)。</p><p>但是需要注意：在使用时，发现有一台服务器的<code>Nginx</code>服务启动后有4个<code>Nginx</code>进程，而<code>Nginx</code>服务关闭后，仍然存在2个<code>Nginx</code>进程，另外一台是正常的，可能是安装是出现问题。</p><p><code>Nginx</code>服务启动后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@192 ~]# ps aux | grep nginx</span><br><span class="line">root      22177  0.0  0.0  10648  3392 ?        Ss   14:00   0:00 nginx: master process nginx -g daemon off;</span><br><span class="line">101       22230  0.0  0.0  11088  1484 ?        S    14:00   0:00 nginx: worker process</span><br><span class="line">root      22365  0.0  0.0 105496  1976 ?        Ss   14:02   0:00 nginx: master process /usr/sbin/nginx</span><br><span class="line">Nginx     22366  0.0  0.0 108048  3376 ?        S    14:02   0:00 nginx: worker process</span><br></pre></td></tr></table></figure><p><code>Nginx</code>服务关闭后：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@192 ~]<span class="comment"># ps aux | grep nginx</span></span><br><span class="line">root      22177  0.0  0.0  10648  3392 ?        Ss   14:00   0:00 nginx: master process nginx -g daemon off;</span><br><span class="line">101       22230  0.0  0.0  11088  1484 ?        S    14:00   0:00 nginx: worker process</span><br></pre></td></tr></table></figure><p>所以针对这台服务器，使用上面的<code>Nginx</code>状态检查脚本，就无法正常检测出<code>Nginx</code>是否存活。因为当关闭<code>Nginx</code>服务后，脚本中的 “<code>ps -C Nginx --no-header|wc -l</code>“ 语句仍然返回2，而不是0，也就不会执行后面启动<code>Nginx</code>的命令了。这时，就需要修改脚本，保证能正常检测<code>Nginx</code>是否存活。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>修改<code>Nginx</code>服务器的<code>html</code>主页文件”<code>/usr/share/Nginx/html/index.html</code>“，在<code>master</code>和<code>backup</code>上分别加入区分描述，用于测试使用。</p><p>分别启动<code>master</code>和<code>backup</code>服务器上的<code>Nginx</code>和<code>Keepalived</code>服务，浏览器访问<a href="http://192.168.0.8，返回如下：">http://192.168.0.8，返回如下：</a></p><p><img src="https://i.loli.net/2021/04/11/ME3ROILTktoVjxX.png" alt="1.png"></p><p>然后关闭<code>master</code>服务器上的<code>Nginx</code>和<code>Keepalived</code>服务，返回如下：</p><p><img src="https://i.loli.net/2021/04/11/xPYh5Dy2uW4qLQ8.png" alt="2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nginx反向代理集群部署&quot;&gt;&lt;a href=&quot;#Nginx反向代理集群部署&quot; class=&quot;headerlink&quot; title=&quot;Nginx反向代理集群部署&quot;&gt;&lt;/a&gt;Nginx反向代理集群部署&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; cla</summary>
      
    
    
    
    <category term="开源组件" scheme="https://imalan6.github.io/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
    
    <category term="nginx" scheme="https://imalan6.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>生产环境系统运行缓慢问题排查</title>
    <link href="https://imalan6.github.io/2021/06/21/jvm/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%BC%93%E6%85%A2%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>https://imalan6.github.io/2021/06/21/jvm/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%BC%93%E6%85%A2%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</id>
    <published>2021-06-21T15:05:22.000Z</published>
    <updated>2024-02-14T11:20:05.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生产环境系统运行缓慢问题排查"><a href="#生产环境系统运行缓慢问题排查" class="headerlink" title="生产环境系统运行缓慢问题排查"></a>生产环境系统运行缓慢问题排查</h1><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><p>线上环境可能出现系统突然运行缓慢，甚至可能导致线上系统不可用。如果遇到这样的情况，首先需要导出<code>jstack</code>日志和内存信息，然后重启系统，保证系统的可用性。这种情况可能的原因有：</p><ul><li><p>代码中某个位置读取数据量较大，导致系统内存耗尽，从而导致<code>Full GC</code>次数过多，系统缓慢；</p></li><li><p>代码中存在耗时计算，导致 CPU 占用过高，系统运行缓慢；</p></li></ul><p>以上两种是出现频率最高的情况，可能直接导致系统不可用。另外几种情况也可能导致系统运行缓慢：</p><ul><li><p>代码某个位置有阻塞性操作，导致该功能调用比较耗时，但这样情况比较随机；</p></li><li><p>某个线程由于某种原因进入<code>WAITING</code>状态，此时该功能整体不可用，但无法复现；</p></li><li><p>由于锁使用不当，使得多个线程进入死锁状态，导致系统整体运行比较缓慢。</p></li></ul><p>对于这几种情况，通过查看 CPU 和系统内存是无法检查出具体问题的，因为可能 CPU 和系统内存使用情况都不高，但是系统却很慢。遇到这些情况，只有分析系统日志来排查。</p><h2 id="Full-GC次数过多"><a href="#Full-GC次数过多" class="headerlink" title="Full GC次数过多"></a>Full GC次数过多</h2><p>相对来说，这种情况是最容易出现的，尤其是新功能上线时。对于<code>Full GC</code>较多的情况，其主要有如下两个特征：</p><ul><li><p>线上多个线程 CPU 占用率都超过了 100%，通过<code>jstack</code>命令可以看到这些线程主要是垃圾回收线程；</p></li><li><p>通过<code>jstat</code>命令监控<code>GC</code>情况，可以看到<code>Full GC</code>次数非常多，且次数在不断增加。</p></li></ul><p>首先，我们使用<code>top</code>命令查看系统 CPU 的占用情况，如下是系统 CPU 较高的一个情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">top - 08:31:10 up 30 min, 0 <span class="built_in">users</span>, load average: 0.73, 0.58, 0.34</span><br><span class="line">KiB Mem: 2046460 total, 1923864 used, 122596 free, 14388 buffers</span><br><span class="line">KiB Swap: 1048572 total, 0 used, 1048572 free. 1192352 cached Mem</span><br><span class="line"></span><br><span class="line">PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND</span><br><span class="line">9 root 20 0 2557160 288976 15812 S 98.0 14.1 0:42.60 java</span><br></pre></td></tr></table></figure><p>从结果可以看出，有一个进程为 9 的 java应用，它的 CPU 占用率达到了 98.8%，这是很不正常的情况。然后使用如下命令查看下该进程的各个线程运行情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -Hp 9</span><br></pre></td></tr></table></figure><p>该进程下的各个线程运行情况如下：</p><p><img src="https://i.loli.net/2021/03/12/1zUHkiXcTMV6K8Z.png" alt="2.png"></p><p>可以看到进程为9的 Java 程序中各个线程的 CPU 占用情况，然后通过<code>jstack</code>命令查看线程 id 为 10 的线程为什么耗费 CPU 最高。需要注意的是，在<code>jsatck</code>命令展示的结果中，线程 id 都转换成了十六进制形式，可以用如下命令转换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%x\n&quot;</span> 10</span><br><span class="line"></span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>十六进制形式的线程 id 的为 0xa，然后在<code>jstack</code>命令输出结果中查找对应的线程信息：</p><p><img src="https://i.loli.net/2021/03/12/glKzrQ7cHsqxuUR.png" alt="3.png"></p><p>找到<code>nid=0xa</code>的线程，这里<code>nid</code>的意思就是操作系统线程 id 的意思。可以看到线程名称是<code>VM Thread</code>，而<code>VM Thread</code>指的就是垃圾回收的线程。这里我们基本上可以确定，当前系统缓慢的原因主要是垃圾回收过于频繁，导致<code>GC</code>停顿时间较长。通过如下命令可以查看<code>GC</code>的情况：</p><p><img src="https://i.loli.net/2021/03/12/fPH5xDr8ETJSYvG.png" alt="4.png"></p><p>可以看到，这里<code>FGC</code>指的是<code>Full GC</code>数量，高达6793，而且还在不断增长。从而进一步证实了是由于内存溢出导致的系统缓慢。那么确认了内存溢出，但是如何查看是哪些对象导致的内存溢出呢，可以<code>dump</code>出内存日志，然后通过<code>eclipse</code>的<code>MAT</code>工具进行查看，如下是其展示的一个对象树结构：</p><p><img src="https://i.loli.net/2021/03/12/iO3VqcYgIQCsmJn.png" alt="5.png"></p><p>经过<code>MAT</code>工具分析，基本上能确定内存中主要是哪个对象比较消耗内存，然后找到该对象的创建位置，进行处理即可。这里主要是<code>PrintStream</code>最多，但是其内存消耗量也只有 12.2%，也就是说，其还不足以导致大量的<code>Full GC</code>，此时我们需要考虑另外一种情况，就是代码或者第三方依赖的包中有显示的<code>System.gc()</code>调用。这种情况我们查看<code>dump</code>内存得到的文件即可判断，因为其会打印<code>GC</code>原因：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Full GC (System.gc()) [Tenured: 262546K-&gt;262546K(349568K), 0.0014879 secs] 262546K-&gt;262546K(506816K), [Metaspace: 3109K-&gt;3109K(1056768K)], 0.0015151 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]</span><br><span class="line">[GC (Allocation Failure) [DefNew: 2795K-&gt;0K(157248K), 0.0001504 secs][Tenured: 262546K-&gt;402K(349568K), 0.0012949 secs] 265342K-&gt;402K(506816K), [Metaspace: 3109K-&gt;3109K(1056768K)], 0.0014699 secs] [Times: user=0.00</span><br></pre></td></tr></table></figure><p>比如这里第一次<code>GC</code>是由于<code>System.gc()</code>的显示调用导致的，而第二次<code>GC</code>则是<code>JVM</code>主动发起的。总结来说，对于<code>Full GC</code>次数过多，主要有以下两种原因：</p><ul><li><p>代码中一次获取了大量的对象，导致内存溢出，此时可以通过<code>eclipse</code>的<code>MAT</code>工具查看内存中有哪些对象比较多；</p></li><li><p>内存占用不高，但是<code>Full GC</code>次数比较多，此时可能存在显示调用<code>System.gc()</code>导致<code>GC</code>次数过多，可以通过添加<code>-XX:+DisableExplicitGC</code>参数来禁用<code>JVM</code>对显示<code>GC</code>的响应。</p></li></ul><h2 id="CPU占用过高"><a href="#CPU占用过高" class="headerlink" title="CPU占用过高"></a>CPU占用过高</h2><p>CPU 过高可能是系统频繁地进行<code>Full GC</code>，导致系统缓慢。而我们平常也肯能遇到比较耗时的计算，导致 CPU 过高的情况，此时查看方式其实与上面的非常类似。首先我们通过<code>top</code>命令查看当前 CPU 消耗过高的进程是哪个，从而得到进程 id；然后通过<code>top -Hp &lt;pid&gt;</code>来查看该进程中有哪些线程 CPU 过高，一般超过 80%就是比较高的，80% 左右是合理情况。这样我们就能得到 CPU 消耗比较高的线程 id。接着通过该 线程 id 的十六进制表示在<code>jstack</code>日志中查看当前线程具体的堆栈信息。</p><p>在这里就可以区分导致 CPU 过高的原因具体是<code>Full GC</code>次数过多还是代码中有比较耗时的计算了。如果是<code>Full GC</code>次数过多，那么通过<code>jstack</code>得到的线程信息会是类似于<code>VM Thread</code>之类的线程，而如果是代码中有比较耗时的计算，那么我们得到的就是一个线程的具体堆栈信息。如下是一个代码中有比较耗时的计算，导致 CPU 过高的线程信息：</p><p><img src="https://i.loli.net/2021/03/12/38Bw4hmgrXUNZEO.png" alt="0.png"></p><p>这里可以看到，在请求<code>UserController</code>的时候，由于该<code>Controller</code>进行了一个比较耗时的调用，导致该线程的 CPU 一直处于100%。我们可以根据堆栈信息，直接定位到<code>UserController</code>的34行，查看代码中具体是什么原因导致计算量如此之高。</p><h2 id="接口耗时"><a href="#接口耗时" class="headerlink" title="接口耗时"></a>接口耗时</h2><p>对于这种情况，比较典型的例子就是，访问接口返回很慢，而且由于这样的接口耗时是不定时出现的，这就导致了我们在通过<code>jstack</code>命令即使得到了线程访问的堆栈信息，我们也没法判断具体哪个线程是正在执行比较耗时操作的线程。</p><p>对于不定时出现的接口耗时严重问题，定位思路如下：首先找到该接口，通过压测工具不断加大访问力度，如果说该接口中有某个位置是比较耗时的，由于访问频率非常高，那么大多数线程都将阻塞在这里，这将导致多个线程具有相同的堆栈日志，然后分析日志就可以定位到该接口中比较耗时的代码的位置。如下是一个代码中有比较耗时的阻塞操作通过压测工具得到的线程堆栈日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;http-nio-8080-exec-2&quot;</span> <span class="comment">#29 daemon prio=5 os_prio=31 tid=0x00007fd08cb26000 nid=0x9603 waiting on condition [0x00007000031d5000]</span></span><br><span class="line"> java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line"> at java.lang.Thread.<span class="built_in">sleep</span>(Native Method)</span><br><span class="line"> at java.lang.Thread.<span class="built_in">sleep</span>(Thread.java:340)</span><br><span class="line"> at java.util.concurrent.TimeUnit.<span class="built_in">sleep</span>(TimeUnit.java:386)</span><br><span class="line"> at com.aibaobei.user.controller.UserController.detail(UserController.java:18)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;http-nio-8080-exec-3&quot;</span> <span class="comment">#30 daemon prio=5 os_prio=31 tid=0x00007fd08cb27000 nid=0x6203 waiting on condition [0x00007000032d8000]</span></span><br><span class="line"> java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line"> at java.lang.Thread.<span class="built_in">sleep</span>(Native Method)</span><br><span class="line"> at java.lang.Thread.<span class="built_in">sleep</span>(Thread.java:340)</span><br><span class="line"> at java.util.concurrent.TimeUnit.<span class="built_in">sleep</span>(TimeUnit.java:386)</span><br><span class="line"> at com.aibaobei.user.controller.UserController.detail(UserController.java:18)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;http-nio-8080-exec-4&quot;</span> <span class="comment">#31 daemon prio=5 os_prio=31 tid=0x00007fd08d0fa000 nid=0x6403 waiting on condition [0x00007000033db000]</span></span><br><span class="line"> java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line"> at java.lang.Thread.<span class="built_in">sleep</span>(Native Method)</span><br><span class="line"> at java.lang.Thread.<span class="built_in">sleep</span>(Thread.java:340)</span><br><span class="line"> at java.util.concurrent.TimeUnit.<span class="built_in">sleep</span>(TimeUnit.java:386)</span><br><span class="line"> at com.aibaobei.user.controller.UserController.detail(UserController.java:18)</span><br></pre></td></tr></table></figure><p>从上面的日志可以看出，有多个线程都阻塞在了<code>UserController</code>的第18行代码，说明这是一个阻塞点，也就是导致该接口比较缓慢的原因，然后分析代码即可。</p><h2 id="线程WAITING状态"><a href="#线程WAITING状态" class="headerlink" title="线程WAITING状态"></a>线程WAITING状态</h2><p>线程处于 waiting 状态是比较罕见的一种情况，但是也是有可能出现的，而且由于其具有一定的“不可复现性”，在排查的时候是非常难以发现的。笔者曾经就遇到过类似的这种情况，具体的场景是，在使用<code>CountDownLatch</code>时，由于需要每一个并行的任务都执行完成之后才会唤醒主线程往下执行。而当时我们是通过<code>CountDownLatch</code>控制多个线程连接并导出用户的<code>gmail</code>邮箱数据，这其中有一个线程连接上了用户邮箱，但是连接被服务器挂起了，导致该线程一直在等待服务器的响应。最终导致我们的主线程和其余几个线程都处于 WAITING 状态。</p><p>对于这样的问题，查看过<code>jstack</code>日志的读者应该都知道，正常情况下，线上大多数线程都是处于<code>TIMED_WAITING</code>状态，而我们这里出问题的线程所处的状态与其是一模一样的，这就非常容易混淆我们的判断。解决这个问题的思路主要如下：</p><ul><li>通过<code>grep</code>命令在<code>jstack</code>堆栈日志中找出所有的处于<code>TIMED_WAITING</code>状态的线程，将其导出到某个文件中，如<code>a1.log</code>，如下是一个导出的日志文件示例：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Attach Listener&quot;</span> <span class="comment">#13 daemon prio=9 os_prio=31 tid=0x00007fe690064000 nid=0xd07 waiting on condition [0x0000000000000000]</span></span><br><span class="line"><span class="string">&quot;DestroyJavaVM&quot;</span> <span class="comment">#12 prio=5 os_prio=31 tid=0x00007fe690066000 nid=0x2603 waiting on condition [0x0000000000000000]</span></span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span> <span class="comment">#11 prio=5 os_prio=31 tid=0x00007fe690065000 nid=0x5a03 waiting on condition [0x0000700003ad4000]</span></span><br><span class="line"><span class="string">&quot;C1 CompilerThread3&quot;</span> <span class="comment">#9 daemon prio=9 os_prio=31 tid=0x00007fe68c00a000 nid=0xa903 waiting on condition [0x0000000000000000]</span></span><br></pre></td></tr></table></figure><ul><li>等待一段时间之后，比如10s，再次对<code>jstack</code>日志进行<code>grep</code>，将其导出到另一个文件，如<code>a2.log</code>，结果如下所示：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;DestroyJavaVM&quot;</span> <span class="comment">#12 prio=5 os_prio=31 tid=0x00007fe690066000 nid=0x2603 waiting on condition [0x0000000000000000]</span></span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span> <span class="comment">#11 prio=5 os_prio=31 tid=0x00007fe690065000 nid=0x5a03 waiting on condition [0x0000700003ad4000]</span></span><br><span class="line"><span class="string">&quot;VM Periodic Task Thread&quot;</span> os_prio=31tid=0x00007fe68d114000nid=0xa803waiting on condition</span><br></pre></td></tr></table></figure><ul><li>重复步骤2，待导出 3<del>4 个文件之后，我们对导出的文件进行对比，找出其中在这几个文件中一直都存在的用户线程，这个线程基本上就可以确认是包含了处于等待状态有问题的线程。因为正常的请求线程是不会在20</del>30s之后还是处于等待状态的。</li><li>经过排查得到这些线程之后，我们可以继续对其堆栈信息进行排查，如果该线程本身就应该处于等待状态，比如用户创建的线程池中处于空闲状态的线程，那么这种线程的堆栈信息中是不会包含用户自定义的类的。这些都可以排除掉，而剩下的线程基本上就可以确认是我们要找的有问题的线程。通过其堆栈信息，我们就可以得出具体是在哪个位置的代码导致该线程处于等待状态了。</li></ul><p>这里需要说明的是，我们在判断是否为用户线程时，可以通过线程最前面的线程名来判断，因为一般的框架的线程命名都是非常规范的，我们通过线程名就可以直接判断得出该线程是某些框架中的线程，这种线程基本上可以排除掉。而剩余的，比如上面的<code>Thread-0</code>，以及我们可以辨别的自定义线程名，这些都是我们需要排查的对象。</p><p>经过上面的方式进行排查之后，我们基本上就可以得出这里的<code>Thread-0</code>就是我们要找的线程，通过查看其堆栈信息，我们就可以得到具体是在哪个位置导致其处于等待状态了。如下示例中则是在<code>SyncTask</code>的第8行导致该线程进入等待了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Thread-0&quot;</span> <span class="comment">#11 prio=5 os_prio=31 tid=0x00007f9de08c7000 nid=0x5603 waiting on condition [0x0000700001f89000]</span></span><br><span class="line"> java.lang.Thread.State: WAITING (parking)</span><br><span class="line"> at sun.misc.Unsafe.park(Native Method)</span><br><span class="line"> at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)</span><br><span class="line"> at com.aibaobei.chapter2.eg4.SyncTask.lambda$main<span class="variable">$0</span>(SyncTask.java:8)</span><br><span class="line"> at com.aibaobei.chapter2.eg4.SyncTask$$Lambda<span class="variable">$1</span>/1791741888.run(Unknown Source)</span><br><span class="line"> at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure><h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><p>对于死锁，这种情况基本上很容易发现，因为<code>jstack</code>堆栈信息可以很方便检查出死锁，并且在日志中打印具体的死锁线程信息。如下是一个产生死锁的一个<code>jstack</code>日志示例：</p><p><img src="https://i.loli.net/2021/03/12/d8lem9W6SxvwY72.png" alt="1.png"></p><p>可以看到，在<code>jstack</code>堆栈日志的底部，其直接帮我们分析了日志中存在哪些死锁，以及每个死锁的线程堆栈信息。这里有两个用户线程分别在等待对方释放锁，而被阻塞的位置都是在<code>ConnectTask</code>的第5行，此时我们就可以直接定位到该位置，并且进行代码分析，从而找到产生死锁的原因。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要讲解了线上可能出现的五种导致系统缓慢的情况，详细分析了每种情况产生时的现象。根据现象可以通过哪些方式定位得到是这种原因导致的系统缓慢。简要的说，可以分为如下步骤：</p><p>1）通过<code>top</code>命令查看 CPU 占用率高的进程，然后通过<code>top -Hp &lt;pid&gt;</code>命令查看当前进程的各个线程运行情况，找出<code>CPU</code>过高的线程之后，再将线程 id 转换为十六进制形式，最后在<code>jstack</code>日志中查看该线程主要的工作。这里又分为两种情况：</p><ul><li><p>如果是用户线程，则通过查看该线程的堆栈信息定位具体是哪处代码运行比较消耗<code>CPU</code>；</p></li><li><p>如果该线程是<code>VM Thread</code>线程，则通过<code>jstat -gcutil &lt;pid&gt; &lt;period&gt; &lt;times&gt;</code>命令监控当前系统的<code>GC</code>状况，然后通过<code>jmapdump:format=b,file=&lt;filepath&gt; &lt;pid&gt;</code>导出系统当前的内存数据。并通过<code>eclipse</code>的<code>MAT</code>内存分析工具查看具体是什么对象比较消耗内存，最后再修改相关代码；详见 <a href="jvm/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83CPU100%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF.md">生产环境CPU 100%解决思路</a>。</p></li></ul><p>2）如果通过<code>top</code>命令看到<code>CPU</code>并不高，并且系统内存占用率也比较低。此时就可以考虑是否是由于另外三种情况导致的问题。具体的可以根据具体情况分析：</p><p>3）如果是接口调用比较耗时，并且是不定时出现，则可以通过压测的方式加大阻塞点出现的频率，并通过<code>jstack</code>查看堆栈信息，找到系统阻塞点；</p><p>4）如果是某个功能突然出现停滞状况，这种情况也无法复现，此时可以通过多次导出<code>jstack</code>日志的方式对比哪些用户线程是一直都处于等待状态，这些线程就是可能存在问题的线程；</p><p>5）如果通过<code>jstack</code>查看到死锁线程，则可以检查导致线程死锁的具体资源并处理相应的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生产环境系统运行缓慢问题排查&quot;&gt;&lt;a href=&quot;#生产环境系统运行缓慢问题排查&quot; class=&quot;headerlink&quot; title=&quot;生产环境系统运行缓慢问题排查&quot;&gt;&lt;/a&gt;生产环境系统运行缓慢问题排查&lt;/h1&gt;&lt;h2 id=&quot;主要问题&quot;&gt;&lt;a href=&quot;#主</summary>
      
    
    
    
    <category term="jvm" scheme="https://imalan6.github.io/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://imalan6.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud系列之Sleuth和Zipkin</title>
    <link href="https://imalan6.github.io/2021/05/26/springcloud/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BSleuth%E5%92%8CZipkin/"/>
    <id>https://imalan6.github.io/2021/05/26/springcloud/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BSleuth%E5%92%8CZipkin/</id>
    <published>2021-05-26T15:09:16.000Z</published>
    <updated>2024-02-14T12:08:50.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud系列之Sleuth和Zipkin"><a href="#SpringCloud系列之Sleuth和Zipkin" class="headerlink" title="SpringCloud系列之Sleuth和Zipkin"></a>SpringCloud系列之Sleuth和Zipkin</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>当采用微服务架构开发时，服务会按照不同的维度进行拆分，各业务之间通过接口相互调用。一个用户请求，可能需要很多微服务的相互调用才能完成。如果在业务调用链路上任何一个微服务出现问题或者网络超时，都可能导致功能失败。因此，我们需要一些可以帮助理解系统行为，并用于系统性能分析的工具，以便发生故障的时候，能够快速地定位和解决问题。随着业务越来越多，几乎每一个请求都会形成一个复杂的分布式服务调用链路，而对于微服务之间调用链路的分析会越来越复杂，类似下图所示：</p><p><img src="https://i.loli.net/2021/03/26/cZh8VebGIql5xNk.png" alt="3.png"></p><p>谷歌在<code>Dapper</code>的论文中，提出了”链路追踪“的概念。链路追踪就是指一次任务的开始到结束，期间调用的所有系统及耗时（时间跨度）都可以完整记录下来。而<code>Spring Cloud Sleuth</code>就是<code>Spring Cloud</code>推出的分布式跟踪解决方案，并兼容支持了<code>Zipkin</code>（<code>Twitter</code>推出的分布式链路跟踪系统）和其他基于日志的追踪系统。通过Sleuth我们可以很清楚地掌握每一个请求经过了哪些服务，每个服务处理了多少时间，这让我们可以很方便地理清各个微服务间的调用关系。另外，<code>Sleuth</code>还提供如下功能：</p><ul><li><p><strong>耗时分析：</strong>通过<code>Sleuth</code>可以很清楚地了解到每个采样请求的耗时，从而分析出哪些服务调用比较耗时;</p></li><li><p><strong>可视化错误：</strong>对于程序未捕捉的异常，可以通过集成<code>Zipkin</code>服务界面上看到;</p></li><li><p><strong>链路优化：</strong>对于调用比较频繁的服务，可以针对这些服务实施一些优化措施。</p></li></ul><p>为了实现平台无关、厂商无关的分布式服务跟踪，<code>CNCF</code>发布了布式服务跟踪标准<code>Open Tracing</code>。目前，业界使用最广泛的分布式链路跟踪系统是<code>Twitter</code>的<code>Zipkin</code>。而国内各大企业自己使用的，主要有淘宝的 “鹰眼”，京东的 “<code>Hydra</code>”，大众点评的 “<code>CAT</code>”以及新浪的 “<code>Watchman</code>”等。</p><h2 id="Sleuth"><a href="#Sleuth" class="headerlink" title="Sleuth"></a>Sleuth</h2><p>链路跟踪的跟踪单元是从用户发起请求(<code>Request</code>)到系统的边界开始，然后到系统返回响应(<code>Response</code>)为止的过程，整个过程称为一个<code>Trace</code>。</p><p>每个<code>Trace</code>中可能会调用多个服务，在每次调用服务时，添加一个调用记录，用来记录每次调用消耗的时间等信息，这个调用记录称为一个Span。</p><p>若干个有序的<code>Span</code>组成了一个<code>Trace</code>。在系统向外界提供服务时，会不断地有请求和响应发生，也就会不断地生成<code>Trace</code>，把这些带有<code>Span</code>的<code>Trace</code>统计出来，就构成了一幅完成的系统调用链路拓扑图。然后再附上<code>Span</code>中的响应时间，请求成功与否等信息，就可以在出现问题时，很方便地找到异常服务。</p><p><img src="https://i.loli.net/2021/03/26/zZni2k6VKcAwRlu.png" alt="0.png"></p><p>一个<code>Trace</code>是一次完整的调用链路，内部包含多个<code>Span</code>。<code>Trace</code>和<code>Span</code>是一对多的关系，而<code>Span</code>与<code>Span</code>之间存在父子关系，一系列的<code>Span</code>组成了树状结构。</p><p>比如：用户请求调用服务 C 、服务 D 、服务 E，其中服务 C 就是一个 <code>Span</code>，如果在服务 C 中另起一个线程调用了服务 D，那么服务 D 就是服务 C 的子 <code>Span</code>，如果在服务 D 中又另起一个线程调用了服务 E，那么服务 E 就是服务 D 的子 <code>Span</code>，而这个 C -&gt; D -&gt; E 构成的调用链路就是一条<code>Trace</code>。将链路调用数据汇总，类似如下图所示：</p><p><img src="https://i.loli.net/2021/03/26/TRzrv4ixj5uyE8N.png" alt="1.png"></p><h2 id="Zipkin"><a href="#Zipkin" class="headerlink" title="Zipkin"></a>Zipkin</h2><p><code>Zipkin</code>是<code>Twitter</code>的一个开源项目，它基于<code>Google Dapper</code>实现，它致力于收集服务的定时数据，包括数据的收集、存储、查找和显示。可以使用它来收集各个服务器上请求链路的跟踪数据，并通过它提供的<code>REST API</code>接口查询跟踪数据以实现对分布式系统的监控程序，从而及时地解决微服务系统中的性能问题，<code>Zipkin</code>还提供了可视化的<code>UI</code>组件帮助我们直观地搜索跟踪信息和分析请求链路细节。</p><p><img src="https://i.loli.net/2021/03/26/Jl6FB9tj4vMVX8b.png" alt="2.png"></p><p><code>Zipkin</code>主要包括 4 个核心组件：</p><ul><li><strong>Collector：</strong>收集器，主要用于处理从外部系统发送过来的跟踪信息，将这些信息转换为<code>Zipkin</code>内部处理的<code>Span</code>格式，以支持存储、分析、展示等功能。</li><li><strong>Storage：</strong>存储组件，主要对处理收集器接收到的跟踪信息进行存储，默认存储在内存中。可以修改此存储策略，使用其他存储，比如<code>Mysql</code>。</li><li><strong>RESTful API：</strong><code>API</code>接口，用来提供外部访问接口。比如给客户端展示跟踪信息，或是外接系统访问监控数据等。</li><li><strong>Web UI：</strong><code>UI</code>组件，基于<code>API</code>组件实现的上层<code>UI</code>显示，可以很方便地查询和分析跟踪信息。</li></ul><p><code>Zipkin</code>分为服务端和客户端两部分。客户端直接部署在微服务上，一旦发生服务间的调用，会被<code>Sleuth</code>监听到，然后生成<code>Trace</code>和<code>Span</code>信息并发送到<code>Zipkin</code>服务端。发送的方式有两种：一种是采用<code>Http</code>报文的方式，另一种是采用消息队列发送，比如<code>RabbitMQ</code>。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h4 id="1-服务端"><a href="#1-服务端" class="headerlink" title="1.服务端"></a>1.服务端</h4><p>在使用<code>Spring Boot 2.x</code>版本后，官方就不推荐自行定制编译<code>Zipkin</code>，而是直接提供了编译好的<code>jar</code>包供使用。使用如下命令安装运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://zipkin.io/quickstart.sh | bash -s</span><br><span class="line">java -jar zipkin.jar</span><br></pre></td></tr></table></figure><p>如果使用Docker的话，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker pull openzipkin/zipkin</span></span><br><span class="line"><span class="comment">#docker run -d -p 9411:9411 openzipkin/zipkin</span></span><br></pre></td></tr></table></figure><p>启动<code>Zipkin</code>服务端后，访问 <a href="http://localhost:9411/zipkin/">http://localhost:9411/zipkin/</a> ，界面显示如下：</p><p><img src="https://i.loli.net/2021/03/26/IcU5zksnBlNt8Kd.png" alt="4.png"></p><h4 id="2-客户端"><a href="#2-客户端" class="headerlink" title="2.客户端"></a>2.客户端</h4><p>1）添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">sleuth:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">sampler:</span></span><br><span class="line">      <span class="attr">probability:</span> <span class="number">1.0</span> <span class="comment">#将采样比例设置为1.0，也就是全部都需要。默认是0.1</span></span><br><span class="line">      <span class="attr">sender:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">web</span> <span class="comment">#数据传输方式，web 表示以 HTTP 报文的形式向服务端发送数据</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://192.168.0.6:9411/</span> <span class="comment">#zipkin服务器的地址</span></span><br></pre></td></tr></table></figure><p><code>Spring Cloud Sleuth</code>有一个<code>Sampler</code>策略，用来控制数据采样算法。采样器不会阻碍<code>span</code>相关<code>id</code>的产生，但是会对导出以及附加事件标签的相关操作产生影响。 <code>Sleuth</code>默认采样算法是<code>Reservoir sampling</code>，默认的采样比例为 0.1(即 10%)。可以通过<code>spring.sleuth.sampler.percentage</code>设置，值介于0.0到1.0之间，1.0表示全部采集。</p><h4 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h4><p>模拟用户发起服务请求，然后查看打开<code>Zipkin UI</code>界面，显示链路请求数据如下：</p><p><img src="https://i.loli.net/2021/03/26/1AKGOR6P7BzxpMX.png" alt="5.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringCloud系列之Sleuth和Zipkin&quot;&gt;&lt;a href=&quot;#SpringCloud系列之Sleuth和Zipkin&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud系列之Sleuth和Zipkin&quot;&gt;&lt;/a&gt;Sprin</summary>
      
    
    
    
    <category term="微服务" scheme="https://imalan6.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="srpingcloud" scheme="https://imalan6.github.io/tags/srpingcloud/"/>
    
    <category term="链路追踪" scheme="https://imalan6.github.io/tags/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>查看 MySQL 数据库容量大小，表容量大小，索引容量大小</title>
    <link href="https://imalan6.github.io/2021/05/22/mysql/%E6%9F%A5%E7%9C%8B%20MySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%B9%E9%87%8F%E5%A4%A7%E5%B0%8F%EF%BC%8C%E8%A1%A8%E5%AE%B9%E9%87%8F%E5%A4%A7%E5%B0%8F%EF%BC%8C%E7%B4%A2%E5%BC%95%E5%AE%B9%E9%87%8F%E5%A4%A7%E5%B0%8F/"/>
    <id>https://imalan6.github.io/2021/05/22/mysql/%E6%9F%A5%E7%9C%8B%20MySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%B9%E9%87%8F%E5%A4%A7%E5%B0%8F%EF%BC%8C%E8%A1%A8%E5%AE%B9%E9%87%8F%E5%A4%A7%E5%B0%8F%EF%BC%8C%E7%B4%A2%E5%BC%95%E5%AE%B9%E9%87%8F%E5%A4%A7%E5%B0%8F/</id>
    <published>2021-05-22T13:33:29.000Z</published>
    <updated>2024-02-17T11:12:16.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、查看-MySQL「所有库」的容量大小"><a href="#一、查看-MySQL「所有库」的容量大小" class="headerlink" title="一、查看 MySQL「所有库」的容量大小"></a>一、查看 MySQL「所有库」的容量大小</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">table_schema <span class="keyword">as</span> <span class="string">&#x27;数据库&#x27;</span>,</span><br><span class="line"><span class="built_in">sum</span>(table_rows) <span class="keyword">as</span> <span class="string">&#x27;记录数&#x27;</span>,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">truncate</span>(data_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>)) <span class="keyword">as</span> <span class="string">&#x27;数据容量(MB)&#x27;</span>,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">truncate</span>(index_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>)) <span class="keyword">as</span> <span class="string">&#x27;索引容量(MB)&#x27;</span>,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">truncate</span>(DATA_FREE<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>)) <span class="keyword">as</span> <span class="string">&#x27;碎片占用(MB)&#x27;</span></span><br><span class="line"><span class="keyword">from</span> information_schema.tables</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> table_schema</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">sum</span>(data_length) <span class="keyword">desc</span>, <span class="built_in">sum</span>(index_length) <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>data_length</code> 、<code>index_length</code> 等字段，所存储的容量信息单位是字节，所以我要除以 2 个 1024 把字节转化为 MB。</p></blockquote><h3 id="二、查看-MySQL「指定库」的容量大小"><a href="#二、查看-MySQL「指定库」的容量大小" class="headerlink" title="二、查看 MySQL「指定库」的容量大小"></a>二、查看 MySQL「指定库」的容量大小</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">table_schema <span class="keyword">as</span> <span class="string">&#x27;数据库&#x27;</span>,</span><br><span class="line"><span class="built_in">sum</span>(table_rows) <span class="keyword">as</span> <span class="string">&#x27;记录数&#x27;</span>,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">truncate</span>(data_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>)) <span class="keyword">as</span> <span class="string">&#x27;数据容量(MB)&#x27;</span>,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">truncate</span>(index_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>)) <span class="keyword">as</span> <span class="string">&#x27;索引容量(MB)&#x27;</span>,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">truncate</span>(DATA_FREE<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>)) <span class="keyword">as</span> <span class="string">&#x27;碎片占用(MB)&#x27;</span></span><br><span class="line"><span class="keyword">from</span> information_schema.tables</span><br><span class="line"><span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;&lt;数据库名&gt;&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> data_length <span class="keyword">desc</span>, index_length <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h3 id="三、查看-MySQL「指定库」中「所有表」的容量大小"><a href="#三、查看-MySQL「指定库」中「所有表」的容量大小" class="headerlink" title="三、查看 MySQL「指定库」中「所有表」的容量大小"></a>三、查看 MySQL「指定库」中「所有表」的容量大小</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  table_schema <span class="keyword">as</span> <span class="string">&#x27;数据库&#x27;</span>,</span><br><span class="line">  table_name <span class="keyword">as</span> <span class="string">&#x27;表名&#x27;</span>,</span><br><span class="line">  table_rows <span class="keyword">as</span> <span class="string">&#x27;记录数&#x27;</span>,</span><br><span class="line">  <span class="keyword">truncate</span>(data_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">as</span> <span class="string">&#x27;数据容量(MB)&#x27;</span>,</span><br><span class="line">  <span class="keyword">truncate</span>(index_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">as</span> <span class="string">&#x27;索引容量(MB)&#x27;</span>,</span><br><span class="line">  <span class="keyword">truncate</span>(DATA_FREE<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">as</span> <span class="string">&#x27;碎片占用(MB)&#x27;</span></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">  information_schema.tables</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">  table_schema<span class="operator">=</span><span class="string">&#x27;&lt;数据库名&gt;&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> </span><br><span class="line">  data_length <span class="keyword">desc</span>, index_length <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h3 id="四、查看-MySQL「指定库」中「指定表」的容量大小"><a href="#四、查看-MySQL「指定库」中「指定表」的容量大小" class="headerlink" title="四、查看 MySQL「指定库」中「指定表」的容量大小"></a>四、查看 MySQL「指定库」中「指定表」的容量大小</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  table_schema <span class="keyword">as</span> <span class="string">&#x27;数据库&#x27;</span>,</span><br><span class="line">  table_name <span class="keyword">as</span> <span class="string">&#x27;表名&#x27;</span>,</span><br><span class="line">  table_rows <span class="keyword">as</span> <span class="string">&#x27;记录数&#x27;</span>,</span><br><span class="line">  <span class="keyword">truncate</span>(data_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">as</span> <span class="string">&#x27;数据容量(MB)&#x27;</span>,</span><br><span class="line">  <span class="keyword">truncate</span>(index_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">as</span> <span class="string">&#x27;索引容量(MB)&#x27;</span>,</span><br><span class="line">  <span class="keyword">truncate</span>(DATA_FREE<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">as</span> <span class="string">&#x27;碎片占用(MB)&#x27;</span></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">  information_schema.tables</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">  table_schema<span class="operator">=</span><span class="string">&#x27;&lt;数据库名&gt;&#x27;</span> <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;&lt;表名&gt;&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> </span><br><span class="line">  data_length <span class="keyword">desc</span>, index_length <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h3 id="五、查看-MySQL-数据库中，容量排名前-10-的表"><a href="#五、查看-MySQL-数据库中，容量排名前-10-的表" class="headerlink" title="五、查看 MySQL 数据库中，容量排名前 10 的表"></a>五、查看 MySQL 数据库中，容量排名前 10 的表</h3><p>首先，先进入 <code>information_schema</code> 库里，然后执行以下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">USE information_schema;</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  TABLE_SCHEMA <span class="keyword">as</span> <span class="string">&#x27;数据库&#x27;</span>,</span><br><span class="line">  table_name <span class="keyword">as</span> <span class="string">&#x27;表名&#x27;</span>,</span><br><span class="line">  table_rows <span class="keyword">as</span> <span class="string">&#x27;记录数&#x27;</span>,</span><br><span class="line">  ENGINE <span class="keyword">as</span> <span class="string">&#x27;存储引擎&#x27;</span>,</span><br><span class="line">  <span class="keyword">truncate</span>(data_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">as</span> <span class="string">&#x27;数据容量(MB)&#x27;</span>,</span><br><span class="line">  <span class="keyword">truncate</span>(index_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">as</span> <span class="string">&#x27;索引容量(MB)&#x27;</span>,</span><br><span class="line">  <span class="keyword">truncate</span>(DATA_FREE<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">as</span> <span class="string">&#x27;碎片占用(MB)&#x27;</span></span><br><span class="line"><span class="keyword">from</span>  tables </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> table_rows <span class="keyword">desc</span> limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="六、查看-MySQL「指定库」中，容量排名前-10-的表"><a href="#六、查看-MySQL「指定库」中，容量排名前-10-的表" class="headerlink" title="六、查看 MySQL「指定库」中，容量排名前 10 的表"></a>六、查看 MySQL「指定库」中，容量排名前 10 的表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">USE information_schema;</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  TABLE_SCHEMA <span class="keyword">as</span> <span class="string">&#x27;数据库&#x27;</span>,</span><br><span class="line">  table_name <span class="keyword">as</span> <span class="string">&#x27;表名&#x27;</span>,</span><br><span class="line">  table_rows <span class="keyword">as</span> <span class="string">&#x27;记录数&#x27;</span>,</span><br><span class="line">  ENGINE <span class="keyword">as</span> <span class="string">&#x27;存储引擎&#x27;</span>,</span><br><span class="line">  <span class="keyword">truncate</span>(data_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">as</span> <span class="string">&#x27;数据容量(MB)&#x27;</span>,</span><br><span class="line">  <span class="keyword">truncate</span>(index_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">as</span> <span class="string">&#x27;索引容量(MB)&#x27;</span>,</span><br><span class="line">  <span class="keyword">truncate</span>(DATA_FREE<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">as</span> <span class="string">&#x27;碎片占用(MB)&#x27;</span></span><br><span class="line"><span class="keyword">from</span>  tables </span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">  table_schema<span class="operator">=</span><span class="string">&#x27;&lt;数据库名&gt;&#x27;</span> </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> table_rows <span class="keyword">desc</span> limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、查看-MySQL「所有库」的容量大小&quot;&gt;&lt;a href=&quot;#一、查看-MySQL「所有库」的容量大小&quot; class=&quot;headerlink&quot; title=&quot;一、查看 MySQL「所有库」的容量大小&quot;&gt;&lt;/a&gt;一、查看 MySQL「所有库」的容量大小&lt;/h3&gt;&lt;</summary>
      
    
    
    
    <category term="数据库" scheme="https://imalan6.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="mysql" scheme="https://imalan6.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>对象引用关系总结</title>
    <link href="https://imalan6.github.io/2021/05/12/jvm/%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93/"/>
    <id>https://imalan6.github.io/2021/05/12/jvm/%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93/</id>
    <published>2021-05-12T07:59:59.000Z</published>
    <updated>2024-02-13T06:00:28.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象引用关系总结"><a href="#对象引用关系总结" class="headerlink" title="对象引用关系总结"></a>对象引用关系总结</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java 执行<code>GC</code>时判断对象是否存活有两种方式，其中一种是引用计数。</p><blockquote><p><strong>引用计数</strong>：Java堆中每一个对象都有一个引用计数属性，引用每新增1次计数加1，引用每释放1次计数减1。</p></blockquote><p>在<code>JDK 1.2</code>以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可达状态（<code>reachable</code>），程序才能使用它。从<code>JDK 1.2</code>版本开始，对象的引用被划分为4种级别，使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：<strong>强引用</strong>、<strong>软引用</strong>、<strong>弱引用</strong>和<strong>虚引用</strong>。</p><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>强引用是使用最普遍的引用。<strong>如果一个对象具有强引用，那垃圾回收器绝不会回收它</strong>。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">strongReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>当内存空间不足时，<code>Java</code>虚拟机宁愿抛出<code>OutOfMemoryError</code>错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 如果强引用对象不使用时，需要弱化从而使<code>GC</code>能够回收，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strongReference = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>显式地设置<code>strongReference</code>对象为<code>null</code>，或让其超出对象的生命周期范围，则<code>gc</code>认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于<code>GC</code>算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">strongReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个方法的内部有一个强引用，这个引用保存在 Java 栈中，而真正的引用内容<code>Object</code>保存在 Java 堆中。 当这个方法运行完成后，就会退出方法栈，则引用对象的引用数为0，这个对象会被回收。</p><p>但是如果这个<code>strongReference</code>是全局变量时，就需要在不用这个对象时赋值为<code>null</code>，因为强引用不会被垃圾回收。</p><p>比如，<code>ArrayList</code>的<code>Clear</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>ArrayList</code>类中定义了一个<code>elementData</code>数组，在调用<code>clear</code>方法清空数组时，每个数组元素被赋值为<code>null</code>。 不同于<code>elementData = null</code>，强引用仍然存在，避免在后续调用<code>add()</code>等方法添加元素时进行内存的重新分配。 使用如<code>clear()</code>方法内存数组中存放的引用类型进行内存释放特别适用，这样就可以及时释放内存。</p><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>如果一个对象只具有软引用，则内存空间充足时，垃圾回收器就不会回收它；<strong>如果内存空间不足了，就会回收这些对象的内存</strong>。只要垃圾回收器没有回收它，该对象就可以被程序使用。</p><blockquote><p>软引用可用来实现内存敏感的<strong>高速缓存</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strongReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 软引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure><p>软引用可以和一个引用队列 (<code>ReferenceQueue</code>) 联合使用。如果软引用所引用对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;String&gt; referenceQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(str, referenceQueue);</span><br><span class="line"></span><br><span class="line">str = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// Notify GC</span></span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line">System.out.println(softReference.get()); <span class="comment">// abc</span></span><br><span class="line"></span><br><span class="line">Reference&lt;? <span class="keyword">extends</span> <span class="title class_">String</span>&gt; reference = referenceQueue.poll();</span><br><span class="line">System.out.println(reference); <span class="comment">//null</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：软引用对象是在 JVM 内存不够的时候才会被回收，我们调用<code>System.gc()</code>方法只是起通知作用，JVM 什么时候扫描回收对象是 JVM 自己的状态决定的。就算扫描到软引用对象也不一定会回收它，只有内存不够的时候才会回收。</p></blockquote><p>当内存不足时，<code>JVM</code>首先将软引用中的对象引用置为<code>null</code>，然后通知垃圾回收器进行回收：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(JVM内存不足) &#123;</span><br><span class="line">    <span class="comment">// 将软引用中的对象引用置为null</span></span><br><span class="line">    str = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 通知垃圾回收器进行回收</span></span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，垃圾收集线程会在虚拟机抛出<code>OutOfMemoryError</code>之前回收软引用对象，而且虚拟机会尽可能优先回收长时间闲置不用的软引用对象。对那些刚构建的或刚使用过的”较新的”软对象会被虚拟机尽可能保留，这就是引入引用队列<code>ReferenceQueue</code>的原因。</p><ul><li><strong>应用场景</strong></li></ul><p>浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。</p><p>1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建；</p><p>2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出。</p><p>这时候就可以使用软引用，很好的解决了实际的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取浏览器对象进行浏览</span></span><br><span class="line"><span class="type">Browser</span> <span class="variable">browser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Browser</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从后台程序加载浏览页面</span></span><br><span class="line"><span class="type">BrowserPage</span> <span class="variable">page</span> <span class="operator">=</span> browser.getPage();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将浏览完毕的页面置为软引用</span></span><br><span class="line"><span class="type">SoftReference</span> <span class="variable">softReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoftReference</span>(page);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回退或者再次浏览此页面时</span></span><br><span class="line"><span class="keyword">if</span>(softReference.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 内存充足，还没有被回收器回收，直接获取缓存</span></span><br><span class="line">    page = softReference.get();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 内存不足，软引用的对象已经回收</span></span><br><span class="line">    page = browser.getPage();</span><br><span class="line">    <span class="comment">// 重新构建软引用</span></span><br><span class="line">    softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，<strong>一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</strong>。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">WeakReference&lt;String&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(str);</span><br><span class="line">str = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><code>JVM</code>首先将软引用中的对象引用置为<code>null</code>，然后通知垃圾回收器进行回收：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="literal">null</span>;</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果一个对象是偶尔使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。</p></blockquote><p>下面的代码会让一个弱引用再次变为一个强引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">WeakReference&lt;String&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(str);</span><br><span class="line"><span class="comment">// 弱引用转强引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strongReference</span> <span class="operator">=</span> weakReference.get();</span><br></pre></td></tr></table></figure><p>同样，弱引用可以和一个引用队列(<code>ReferenceQueue</code>)联合使用，如果弱引用所引用的对象被垃圾回收，JVM 就会把这个弱引用加入到与之关联的引用队列中。</p><ul><li><strong>测试实例</strong></li></ul><p><code>GCTarget.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTarget</span> &#123;</span><br><span class="line">    <span class="comment">// 对象的ID</span></span><br><span class="line">    <span class="keyword">public</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 占用内存空间</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GCTarget</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 执行垃圾回收时打印显示对象ID</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Finalizing GCTarget, id is : &quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GCTargetWeakReference.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTargetWeakReference</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;GCTarget&gt; &#123;</span><br><span class="line">    <span class="comment">// 弱引用的ID</span></span><br><span class="line">    <span class="keyword">public</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GCTargetWeakReference</span><span class="params">(GCTarget gcTarget,</span></span><br><span class="line"><span class="params">              ReferenceQueue&lt;? <span class="built_in">super</span> GCTarget&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(gcTarget, queue);</span><br><span class="line">        <span class="built_in">this</span>.id = gcTarget.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finalizing GCTargetWeakReference &quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WeakReferenceTest.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReferenceTest</span> &#123;</span><br><span class="line">    <span class="comment">// 弱引用队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ReferenceQueue&lt;GCTarget&gt; REFERENCE_QUEUE = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedList&lt;GCTargetWeakReference&gt; gcTargetList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建弱引用的对象，依次加入链表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">GCTarget</span> <span class="variable">gcTarget</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GCTarget</span>(String.valueOf(i));</span><br><span class="line">            <span class="type">GCTargetWeakReference</span> <span class="variable">weakReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GCTargetWeakReference</span>(gcTarget,</span><br><span class="line">                REFERENCE_QUEUE);</span><br><span class="line">            gcTargetList.add(weakReference);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Just created GCTargetWeakReference obj: &quot;</span> +</span><br><span class="line">                gcTargetList.getLast());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知GC进行垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 休息几分钟，等待上面的垃圾回收线程运行完成</span></span><br><span class="line">            Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查关联的引用队列是否为空</span></span><br><span class="line">        Reference&lt;? <span class="keyword">extends</span> <span class="title class_">GCTarget</span>&gt; reference;</span><br><span class="line">        <span class="keyword">while</span>((reference = REFERENCE_QUEUE.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(reference <span class="keyword">instanceof</span> GCTargetWeakReference) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;In queue, id is: &quot;</span> +</span><br><span class="line">                    ((GCTargetWeakReference) (reference)).id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>WeakReferenceTest.java</code>，运行结果如下：</p><p><img src="https://i.loli.net/2021/03/07/g49rofMNJEiGeab.png" alt="0.png"></p><p>可见<code>WeakReference</code>对象的生命周期基本由垃圾回收器决定，一旦垃圾回收线程发现了弱引用对象，在下一次<code>GC</code>过程中就会对其进行回收。</p><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。<strong>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</strong></p><ul><li><strong>应用场景</strong></li></ul><p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。 虚引用与软引用和弱引用的一个区别在于：</p><blockquote><p>虚引用必须和引用队列 (ReferenceQueue) 联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = new String(&quot;abc&quot;);</span><br><span class="line">ReferenceQueue queue = new ReferenceQueue();</span><br><span class="line">// 创建虚引用，要求必须与一个引用队列关联</span><br><span class="line">PhantomReference pr = new PhantomReference(str, queue);</span><br></pre></td></tr></table></figure><p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要进行垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>Java中4种引用的级别和强度由高到低依次为：强引用 -&gt; 软引用 -&gt; 弱引用 -&gt; 虚引用</p></blockquote><p>当垃圾回收器回收时，某些对象会被回收，某些不会被回收。垃圾回收器会从根对象 GC ROOT 来标记存活的对象，然后将某些不可达的对象和一些引用的对象进行回收。</p><table><thead><tr><th>引用类型</th><th>被垃圾回收时间</th><th>用途</th><th>生存时间</th></tr></thead><tbody><tr><td>强引用</td><td>从来不会</td><td>对象的一般状态</td><td>JVM 停止运行时终止</td></tr><tr><td>软引用</td><td>当内存不足时</td><td>对象缓存</td><td>内存不足时终止</td></tr><tr><td>弱引用</td><td>正常垃圾回收时</td><td>对象缓存</td><td>垃圾回收后终止</td></tr><tr><td>虚引用</td><td>正常垃圾回收时</td><td>跟踪对象的垃圾回收</td><td>垃圾回收后终止</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对象引用关系总结&quot;&gt;&lt;a href=&quot;#对象引用关系总结&quot; class=&quot;headerlink&quot; title=&quot;对象引用关系总结&quot;&gt;&lt;/a&gt;对象引用关系总结&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="jvm" scheme="https://imalan6.github.io/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://imalan6.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud系列之Ribbon</title>
    <link href="https://imalan6.github.io/2021/04/21/springcloud/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BRibbon/"/>
    <id>https://imalan6.github.io/2021/04/21/springcloud/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BRibbon/</id>
    <published>2021-04-21T14:16:14.000Z</published>
    <updated>2024-02-14T11:32:17.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud系列之Ribbon"><a href="#SpringCloud系列之Ribbon" class="headerlink" title="SpringCloud系列之Ribbon"></a>SpringCloud系列之Ribbon</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Ribbon</code>是一个由<code>Netflix</code>发布的开源的客户端负载均衡器，它可以控制<code>HTTP</code>和<code>TCP</code>客户端的行为，是<code>SpringCloud-Netflix</code>中重要的一环。通过<code>Ribbon</code>可以将<code>Netflix</code>的中间层服务连接在一起。使用时只需为<code>Ribbon</code>配置服务提供者地址列表，<code>Ribbon</code>就可基于负载均衡算法计算出要请求的目标服务地址。</p><p><code>Ribbon</code>客户端组件提供了一系列完善的配置项，如连接超时、重试等。在配置文件中列出<code>Load Balancer</code>后面所有的服务，<code>Ribbon</code>会自动的基于某种规则（如简单轮询，随机连接，响应时间加权等）去连接这些服务，也很容易实现自定义的负载均衡算法，只需实现<code>IRule</code>接口即可。</p><p><img src="https://i.loli.net/2021/03/21/QBy3TILZYF6CDEz.png" alt="0.png"></p><p><code>Ribbon</code>是在客户端来实现负载均衡的访问服务，主要的功能点：</p><ul><li><p>服务发现，发现依赖服务的列表</p></li><li><p>服务选择规则，在多个服务中如何选择一个有效服务</p></li><li><p>服务监听，检测失效的服务，剔除失效服务</p></li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h4 id="1）配置"><a href="#1）配置" class="headerlink" title="1）配置"></a><strong>1）配置</strong></h4><ul><li>添加依赖：</li></ul><p>由于<code>spring-cloud-starter-netflix-eureka-client</code>已经包含<code>spring-cloud-starter-netfilx-ribbon</code>，所以无需额外添加依赖。</p><ul><li>启动类配置：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &#123;&quot;com.landcode.land.service.consumer.service&quot;&#125;)</span> <span class="comment">// 使用feign调用微服务，如果不使用feign可以不加</span></span><br><span class="line"><span class="meta">@RibbonClient(name = &quot;service-hi&quot;, configuration = RibbonConfig.class)</span> <span class="comment">// 使用自定义配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        SpringApplication.run(UserApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启负载均衡</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码所示，只需在<code>RestTemplate</code>上添加<code>LoadBalanced</code> 注解，即可让整合<code>Ribbon</code>。</p><h4 id="2）RestTemplate-Ribbon使用"><a href="#2）RestTemplate-Ribbon使用" class="headerlink" title="2）RestTemplate + Ribbon使用"></a><strong>2）RestTemplate + Ribbon使用</strong></h4><p><code>RestTemplate</code>是<code>Spring Resources</code>中一个访问第三方<code>RESTful API</code>接口的网络请求框架，用来消费<code>REST</code>服务的。所以<code>RestTemplate</code>的主要方法都与<code>REST</code>的<code>Http</code>协议的一些方法紧密相连，例如<code>HEAD</code>、<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>和<code>OPTIONS</code>等方法，这些方法在<code>RestTemplate</code>类对应的方法为<code>headForHeaders()</code>、<code>getForObject()</code>、<code>postForObject()</code>、<code>put()</code>和<code>delete()</code>等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHiController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hi&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hi</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 使用LoadBalancerClient通过service id获取指定服务</span></span><br><span class="line">    <span class="type">ServiceInstance</span> <span class="variable">serviceInstance</span> <span class="operator">=</span> loadBalancerClient.choose(<span class="string">&quot;service-hi&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(serviceInstance.getUri().toString() + <span class="string">&quot;/hi&quot;</span>, String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中<code>LoadBalancerClient</code>为<code>Ribbon</code>默认的负载均衡<code>API</code>，使用的轮询策略；<code>loadBalancerClient.choose(&quot;consul-provider&quot;)</code>用于获取注册中心服务名称为<code>service-hi</code>的服务，再通过<code>getUri()</code>获取服务的地址；最后通过<code>restTemplate.getForObject</code>调用服务。</p><h4 id="3）Feign-Ribbon使用"><a href="#3）Feign-Ribbon使用" class="headerlink" title="3）Feign + Ribbon使用"></a><strong>3）Feign + Ribbon使用</strong></h4><p><code>Feign</code>是一个声明式的<code>Web Service</code>客户端。它的出现使开发<code>Web Service</code>客户端变得很简单。在<code>Spring Cloud</code>中使用<code>Feign</code>，可以做到使用<code>HTTP</code>请求访问远程服务，就像调用本地方法一样的。详见 <a href="springcloud/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BFeign.md">SpringCloud系列之Feign</a>。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;service-hi&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITestHi</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hi&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testHi</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Feign</code>是整合了<code>Ribbon</code>，使用方式一样。在<code>controller</code>里调用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHiController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ITestHi testHi;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hi&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testHi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> testHi.testHi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><h4 id="1）负载均衡"><a href="#1）负载均衡" class="headerlink" title="1）负载均衡"></a><strong>1）负载均衡</strong></h4><p>当集群里的1台或者多台服务器出现故障时，剩余没有出现故障的服务器可以保证服务正常使用。而对于客户端如何选择调用哪个服务，则需要负载均衡技术。负载均衡有好几种实现策略，常见的有：</p><ul><li>随机 (<code>Random</code>)</li><li>轮询 (<code>RoundRobin</code>)</li><li>一致性哈希 (<code>ConsistentHash</code>)</li><li>哈希 (<code>Hash</code>)</li><li>加权（<code>Weighted</code>）</li></ul><h4 id="2）Ribbon负载均衡策略"><a href="#2）Ribbon负载均衡策略" class="headerlink" title="2）Ribbon负载均衡策略"></a><strong>2）Ribbon负载均衡策略</strong></h4><p><code>Ribbon</code>自带多种负载均衡策略，默认的是轮询策略。分别如下：</p><p><img src="https://i.loli.net/2021/03/21/d7Wq8bB16fQMhuE.png" alt="1.png"></p><ul><li><strong>配置文件配置策略</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过配置文件指定服务的ribbon负载均衡策略为RandomRule</span></span><br><span class="line"><span class="attr">service-hi:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><ul><li><strong>代码配置策略</strong></li></ul><p>为某个服务配置代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RibbonClient(name=&quot;service-hi&quot;,configuration = RibbonConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceHiRibbonConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RibbonConfig</code>类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RibbonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Ribbon提供的负载均衡策略</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IRule <span class="title function_">ribbonRule</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建<code>RibbonConfig</code>类，<code>@RibbonClient</code>注解指定某个服务，针对该服务的配置有效。<code>configuration</code>参数指定为<code>Ribbon</code>的负载均衡策略配置类。如果全局配置，则不指定服务名称，使用<code>@RibbonClients(defaultConfiguration = RibbonConfig.class)</code>；</p><p>当然，也可以不单独创建配置类，像开头那样直接放入启动类中也是可以的。</p><ul><li><strong>自定义策略</strong></li></ul><p>如果<code>Ribbon</code>提供的负载均衡策略不满足业务需求，想要自己实现的话也是可以的。<code>Ribbon</code>支持自定义负载均衡策略，需要继承<code>AbstractLoadBalancerRule</code>类，或者实现<code>IRule</code>接口，实现<code>choose</code>方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRule</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalancerRule</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initWithNiwsConfig</span><span class="params">(IClientConfig iClientConfig)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;key:&quot;</span> + o);</span><br><span class="line">        List&lt;Server&gt; allServers = getLoadBalancer().getAllServers(); <span class="comment">// 获取所有服务实例</span></span><br><span class="line">        <span class="keyword">return</span> allServers.get(<span class="number">0</span>); <span class="comment">//使用列表中第一个服务实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，实现了一个简单的测试策略，即调用服务列表中的第一个服务实例。在真实应用环境中，替换成自己实现的负载均衡算法即可。使用该策略的话，直接将配置类<code>return</code>自定义的策略就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RibbonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IRule <span class="title function_">ribbonRule</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TestRule</span>(); <span class="comment">// 返回自定义的策略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringCloud系列之Ribbon&quot;&gt;&lt;a href=&quot;#SpringCloud系列之Ribbon&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud系列之Ribbon&quot;&gt;&lt;/a&gt;SpringCloud系列之Ribbon&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="微服务" scheme="https://imalan6.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="srpingcloud" scheme="https://imalan6.github.io/tags/srpingcloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud系列之Hystrix</title>
    <link href="https://imalan6.github.io/2021/04/10/springcloud/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BHystrix/"/>
    <id>https://imalan6.github.io/2021/04/10/springcloud/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BHystrix/</id>
    <published>2021-04-10T15:05:15.000Z</published>
    <updated>2024-02-14T11:32:17.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud系列之Hystrix"><a href="#SpringCloud系列之Hystrix" class="headerlink" title="SpringCloud系列之Hystrix"></a>SpringCloud系列之Hystrix</h1><h2 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h2><p>在一个高度服务化的微服务系统中，一个业务逻辑处理通常会依赖多个服务。 如果其中的某一个服务不可用，就会出现线程池里所有线程都因等待响应而被阻塞，从而造成服务雪崩。这种因服务提供者不可用而导致服务调用者不可用，并将不可用逐渐放大传播的过程，就叫服务雪崩效应。比如程序<code>bug</code>、大流量请求、硬件故障、缓存雪崩击穿等。如下是一个分布式系统中服务调用的常见模型：</p><p><img src="https://i.loli.net/2021/03/24/yA2aeO7NMFkKn8j.png" alt="2.png"></p><p>在服务提供者不可用时，服务调用者可能会出现大量重试情况，比如用户手动重试操作、代码逻辑重试操作等，这些重试操作最终导致请求量进一步加大。当服务调用者使用的同步调用时，大量等待线程占用了大量系统资源。一旦线程资源被耗尽，服务调用者提供的服务也将处于不可用状态，于是服务雪崩效应就产生了。所以，导致雪崩效应的根本原因就是大量请求线程同步等待造成的资源耗尽。</p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>导致服务不可用的原因有很多，除了服务提供者不可用之外还有其他因素也可能产生雪崩效应：</p><ul><li>服务调用者请求量激增，导致系统负载升高。比如异常流量、用户重试、代码逻辑重复等。</li><li>缓存击穿，缓存雪崩等，导致请求都直接转向数据库。</li><li>重试机制，比如<code>RPC</code>框架的<code>Retry</code>次数，每次重试都可能会进一步恶化服务提供者。</li><li>硬件故障，比如设备出问题，机房断电等情况。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>针对服务调用者自身请求量激增问题，可以采取自动扩容方式应对突发流量，或在负载均衡器上实现限流功能。</p><p>针对重试问题，可以减少或关闭重试机制。</p><p>针对硬件故障，可以采取多机备份，异地多活等方案。</p><p>针对服务不可用而导致的系统雪崩问题，主要有以下解决方案：</p><ul><li>超时机制</li></ul><p>在不做任何处理的情况下，服务提供者不可用会导致消费者请求线程强制等待，而造成系统资源耗尽。加入超时机制，一旦超时，就释放资源。由于释放资源速度较快，一定程度上可以抑制资源耗尽的问题。</p><ul><li>服务隔离</li></ul><p>限制请求核心服务提供者的流量，把流量拦截在核心服务之外，这样可以更好地保证核心服务提供者不出问题。对于一些出问题的服务可以限制流量访问，只分配固定线程资源访问，这样能使整体的资源不至于被出问题的服务耗尽。可以通过线程池+队列的方式，通过信号量的方式进行处理。</p><ul><li>服务熔断</li></ul><p>当远程服务不稳定或网络抖动严重时暂时关闭。实时监测应用，一旦发现一定时间内服务调用的失败次数&#x2F;失败率达到一定阈值时，服务调用就断开(断路器)。此时，服务请求直接返回，不继续执行原本调用逻辑。断开一段时间后（比如10秒），断路器进入半开状态，此时允许调用一次该服务。如果调用成功，则断路器关闭，服务进入正常调用；如果调用仍然失败，断路器继续回到打开状态。经过一段时间（比如10秒）再进入半开状态，尝试调用服务。通过这种断路器打开—半开—关闭的方式， 可以控制服务调用者是否执行服务调用，从而避免频繁调用失败，浪费系统资源。</p><ul><li>服务降级</li></ul><p>所谓服务降级，就是调用者提前实现一个<code>fallback</code>熔断回调，当某个服务熔断无法被调用时，服务调用者就会调用<code>fallback</code>直接返回一个缺省值。比如，备用接口&#x2F;缓存&#x2F;<code>mock</code>数据等。这样业务处理方式更友好。</p><h2 id="Hystrix使用"><a href="#Hystrix使用" class="headerlink" title="Hystrix使用"></a>Hystrix使用</h2><p><code>Hystrix</code>是由<code>Netflix</code>开源的一个延迟和容错库，提供超时机制、限流、熔断、降级全面的功能实现，主要用于隔离访问远程系统、服务或者第三方库，防止级联失败，从而提升系统的可用性与容错性。</p><h4 id="服务隔离"><a href="#服务隔离" class="headerlink" title="服务隔离"></a>服务隔离</h4><p><code>Hystrix</code>采用了舱壁隔离技术，来将外部依赖进行资源隔离，进而避免任何外部依赖的故障导致本服务崩溃。舱壁隔离，是说将船体内部空间区隔划分成若干个隔舱，一旦某几个隔舱发生破损进水，水流不会在其间相互流动，如此一来船舶在受损时，依然能具有足够的浮力和稳定性，进而减低立即沉船的危险。<code>Hystrix</code>的资源隔离策略有两种，分别为：线程池和信号量。</p><p><img src="https://i.loli.net/2021/03/24/w2JExNzXjsFQy1S.png" alt="5.png"></p><ul><li><strong>线程池</strong></li></ul><p>在<code>Hystrix</code>中，如果不使用线程池隔离策略，而是共用一个线程池的话，服务的调用方式如下图：</p><p><img src="https://i.loli.net/2021/03/24/ps9EIuzlgw1Ay3Y.png" alt="3.png"></p><p>这种方法共用一个线程池的方式很容易出现问题，比如：如果方法A请求量很大，调用的服务处理又很慢，那方法A很容易把线程池的线程用完，那方法B和方法C就没有线程可以使用了，只能等待，结果就是超时被熔断。导致这种情况出现，并不是被调用的服务不可用，而是服务调用者根本没有线程去处理这些请求。</p><p>为了避免上面这种情况，如果<code>Hystrix</code>对每个外部调用都单独配一个线程池，这样即使某个外部调用延迟很严重处理不过来，也只是耗尽自己的那个线程池而已，不会影响其他方法的线程池。这样就使得方法间的调用相互隔离开了，互不影响。如下图：</p><p><img src="https://i.loli.net/2021/03/24/mYOxg8DE2o5U1tu.png" alt="4.png"></p><p><code>Hystrix</code>是通过命令模式，将每个类型的业务请求封装成对应的命令请求，比如A方法-&gt;服务1Command，B方法-&gt;服务1Command，C方法-&gt;服务2Command。每个类型的<code>Command</code>对应一个线程池。创建好的线程池放入到<code>ConcurrentHashMap</code>中，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, HystrixThreadPool&gt; threadPools = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, HystrixThreadPool&gt;();</span><br><span class="line">threadPools.put(“hystrix-order”, <span class="keyword">new</span> <span class="title class_">HystrixThreadPoolDefault</span>(threadPoolKey, propertiesBuilder));</span><br></pre></td></tr></table></figure><ul><li><strong>信号量</strong></li></ul><p>用于隔离本地代码，利用信号量限制同时运行的线程数量。使用一个原子计数器（或信号量）来记录当前有多少个线程在运行，当请求进来时先判断计数器的数值，若超过设置的最大线程个数则拒绝该请求，若不超过则通行，这时候计数器+1，请求返回成功后计数器-1。</p><ul><li><strong>区别</strong></li></ul><p>执行线程区别：线程池隔离方式执行依赖代码的线程不是原来的线程；而信号量方式依然是原来的请求线程。</p><p>应用场景区别：线程池隔离适合并发量比较大的第三方应用或者接口；而信号量隔离适合并发量不大的内部应用或中间件。</p><p>执行效率区别：线程池增加了<code>cpu</code>的开销；而信号量不会创建副线程，开销较小。</p><ul><li><strong>注意</strong></li></ul><p>使用线程池隔离时，在某些业务场景下通过<code>ThreadLocal</code>来传递数据会出现问题。因为线程池隔离方式下，<code>Hystrix</code>会将请求放入方法的线程池去执行，这时请求线程就由A线程变成B线程了，<code>ThreadLocal</code>也就消失了。用信号量没问题的，因为还是原来那个线程在处理。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><h5 id="1）命令方式"><a href="#1）命令方式" class="headerlink" title="1）命令方式"></a>1）命令方式</h5><p><code>hystrix</code>采用了命令模式，客户端需要继承抽象类<code>HystrixCommand</code>并实现其<code>run</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloHystrixCommand要使用Hystrix功能 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloHystrixCommand</span> <span class="keyword">extends</span> <span class="title class_">HystrixCommand</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloHystrixCommand</span><span class="params">(String name)</span> &#123;   </span><br><span class="line">        <span class="built_in">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;ExampleGroup&quot;</span>));     </span><br><span class="line">        <span class="built_in">this</span>.name = name; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 如果继承的是HystrixObservableCommand，要重写Observable construct() </span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">run</span><span class="params">()</span> &#123;     </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="2）注解方式"><a href="#2）注解方式" class="headerlink" title="2）注解方式"></a>2）注解方式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(commandKey = &quot;getCompanyInfoById&quot;,</span><br><span class="line">                    groupKey = &quot;company-info&quot;,</span><br><span class="line">                    threadPoolKey = &quot;company-info&quot;,</span><br><span class="line">                    fallbackMethod = &quot;fallbackMethod&quot;,</span><br><span class="line">                    threadPoolProperties = &#123;</span><br><span class="line">                        @HystrixProperty(name = &quot;coreSize&quot;, value = &quot;30&quot;),</span><br><span class="line">                        @HystrixProperty(name = &quot;maxQueueSize&quot;, value = &quot;101&quot;),</span><br><span class="line">                        @HystrixProperty(name = &quot;keepAliveTimeMinutes&quot;, value = &quot;2&quot;),</span><br><span class="line">                        @HystrixProperty(name = &quot;queueSizeRejectionThreshold&quot;, value = &quot;15&quot;),</span><br><span class="line">                     &#125;)</span><br></pre></td></tr></table></figure><ul><li><code>commandKey</code>：代表一个接口, 如果不配置，默认是<code>@HystrixCommand</code>注解修饰的函数的函数名。</li><li><code>groupKey</code>：代表一个服务，一个服务可能会暴露多个接口。<code>Hystrix</code>命令默认的线程划分也是根据命令组来实现。默认情况下，<code>Hystrix</code>会让相同组名的命令使用同一个线程池，所以我们需要在创建<code>Hystrix</code>命令时为其指定命令组来实现默认的线程池划分。</li><li><code>threadPoolKey</code>：对线程池进行更细粒度的配置，默认等于<code>groupKey</code>的值。如果依赖服务中的某个接口耗时较长，需要单独特殊处理，最好单独用一个线程池，这时候就可以配置threadpool key。</li><li><code>fallbackMethod</code>：<code>@HystrixCommand</code>注解修饰的函数的回调函数，<code>@HystrixCommand</code>修饰的函数必须和这个回调函数定义在同一个类中，因为定义在了同一个类中，所以<code>fackback method</code>可以是<code>public/private</code>均可。</li><li>线程池配置：<code>coreSize</code>表示核心线程数，<code>hystrix</code>默认是10；<code>maxQueueSize</code>表示线程池的最大队列大小；<code>keepAliveTimeMinutes</code>表示非核心线程空闲时最大存活时间；<code>queueSizeRejectionThreshold</code>：该参数用来为队列设置拒绝阈值。通过该参数，即使队列没有达到最大值也能拒绝请求。</li></ul><p>使用实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHelloController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="meta">@HystrixCommand(</span></span><br><span class="line"><span class="meta">            fallbackMethod = &quot;HelloFallback&quot;,// 服务降级方法</span></span><br><span class="line"><span class="meta">            // 使用commandProperties 可以配置熔断的一些细节信息</span></span><br><span class="line"><span class="meta">            commandProperties = &#123;</span></span><br><span class="line"><span class="meta">                    //熔断超时时间2s，类似kv形式</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;2000&quot;)</span></span><br><span class="line"><span class="meta">            &#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHi</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span>  <span class="operator">=</span><span class="string">&quot;http://.....&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(url, Integer.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 服务降级方法，服务降级后调用该方法返回，返回值类型需要和原方法一致</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">HelloFallback</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3）与Feign配合使用"><a href="#3）与Feign配合使用" class="headerlink" title="3）与Feign配合使用"></a>3）与Feign配合使用</h5><p>通过配置<code>@FeignClient</code>注解的<code>fallback</code>属性指定一个自定义的<code>fallback</code>处理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;service-hi&quot;, fallback = HiFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITestHi</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hi&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testHi</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HiFallback</code>需要实现<code>ITestHi</code>接口，并且在<code>Spring</code>容器中注册<code>bean</code>。可以有两种方式：一种直接实现<code>ITestHi</code>接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">HiFallback</span> <span class="keyword">implements</span> <span class="title class_">ITestHi</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testHi</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种实现<code>FallbackFactory&lt;ITestHi&gt;</code>接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">HiFallback</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;ITestHi&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ITestHi <span class="title function_">create</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hystrix监控"><a href="#Hystrix监控" class="headerlink" title="Hystrix监控"></a>Hystrix监控</h2><ul><li><strong>单服务监控</strong></li></ul><p>1）添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）启动类添加注解<code>@EnableHystrixDashboard</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &#123;&quot;com.landcode.land.service.consumer.service&quot;&#125;)</span></span><br><span class="line"><span class="meta">@RibbonClient(name = &quot;service-hi&quot;, configuration = RibbonConfig.class)</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span> <span class="comment">// 打开HystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）测试</p><p>启动<code>hystrix-dashboard</code>后，输入<code>http://localhost:8081/hystrix</code>，出现如下页面：</p><p><img src="https://i.loli.net/2021/03/24/kwITdDYfLVynRoa.png" alt="1.png"></p><p>在第一个文本框输入要监控的服务，采用<code>ip + 端口 + hystrix.stream</code>格式，比如<code>http://localhost:8801/actuator/hystrix.stream</code>，则会跳转到监控页面。如果点击后出现 “<code>Unable to connect to Command Metric Stream.</code>” 错误。则按如下方式解决：</p><p>在监控服务添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">dashboard:</span></span><br><span class="line">    <span class="attr">proxy-stream-allow-list:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>在被监控服务添加配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HystrixDashboardConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletRegistrationBean <span class="title function_">getServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HystrixMetricsStreamServlet</span> <span class="variable">streamServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HystrixMetricsStreamServlet</span>();</span><br><span class="line">        <span class="type">ServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>(streamServlet);</span><br><span class="line">        registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registrationBean.addUrlMappings(<span class="string">&quot;/actuator/hystrix.stream&quot;</span>); <span class="comment">//访问路径</span></span><br><span class="line">        registrationBean.setName(<span class="string">&quot;hystrix.stream&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><strong>Turbine聚合监控数据</strong></li></ul><p>1）创建一个监控服务项目，引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）启动类上配置<code>@EnableTurbine</code>注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">@EnableFeignClients(basePackages = &#123;&quot;com.landcode.land.service.consumer.service&quot;&#125;)</span><br><span class="line">@RibbonClient(name = &quot;service-hi&quot;, configuration = RibbonConfig.class)</span><br><span class="line">@EnableCircuitBreaker</span><br><span class="line">@EnableHystrixDashboard </span><br><span class="line">@EnableTurbine // 打开Turbine</span><br><span class="line">public class ConsumerApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @LoadBalanced</span><br><span class="line">    public RestTemplate restTemplate() &#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）添加如下配置，指明从哪些微服务收集监控数据</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">turbine:</span></span><br><span class="line">  <span class="attr">app-config:</span> <span class="string">hi,test</span></span><br><span class="line">  <span class="attr">cluster-name-expression:</span> <span class="string">&quot;&#x27;default&#x27;&quot;</span></span><br></pre></td></tr></table></figure><p>注意<code>turbine</code>的配置，这里收集<code>hi</code>和<code>test</code>服务的日志</p><p>4）启动监控项目后，在<code>hystrix-dashboard中</code>输入<code>http://localhost:8088/turbine.stream</code>,则展示如下聚合结果：</p><p><img src="https://i.loli.net/2021/03/24/gyeGPKJ8mq17U2n.png" alt="0.png"></p><p>以上<code>Turbine</code>聚合微服务的监控数据，然后在<code>hystrix-dashboard</code>展示多个微服务的实时监控数据。但是<code>Turbine</code>有它的局限性，比如如果微服务之间无法通信，或者服务没在<code>Eureka</code>上注册，则<code>Turbine</code>无法收集到微服务的日志。这种情况下，需要借助消息中间件来解决。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringCloud系列之Hystrix&quot;&gt;&lt;a href=&quot;#SpringCloud系列之Hystrix&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud系列之Hystrix&quot;&gt;&lt;/a&gt;SpringCloud系列之Hystrix&lt;/</summary>
      
    
    
    
    <category term="微服务" scheme="https://imalan6.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="srpingcloud" scheme="https://imalan6.github.io/tags/srpingcloud/"/>
    
    <category term="熔断" scheme="https://imalan6.github.io/tags/%E7%86%94%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud系列之Feign</title>
    <link href="https://imalan6.github.io/2021/03/29/springcloud/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BFeign/"/>
    <id>https://imalan6.github.io/2021/03/29/springcloud/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BFeign/</id>
    <published>2021-03-29T15:11:45.000Z</published>
    <updated>2024-02-14T11:32:17.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud系列之Feign"><a href="#SpringCloud系列之Feign" class="headerlink" title="SpringCloud系列之Feign"></a>SpringCloud系列之Feign</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Feign</code>是一个声明式、模板化的<code>HTTP</code>客户端，简化了系统发起<code>HTTP</code>请求。创建它时，只需要创建一个接口，然后加上<code>@FeignClient</code>注解就行了。使用它调用其他服务时，就像调用本地方法一样，完全感知不到这是在调用远程的方法，也感知不到背后发起的<code>HTTP</code>请求。<code>Feign</code>默认集成了<code>Ribbon</code>，并和<code>Eureka</code>结合，实现了负载均衡的效果。<code>Feign</code>功能如下：</p><ul><li><code>Feign</code>采用的是基于接口的注解；</li><li>支持HTTP请求和响应的压缩；</li><li><code>Feign</code>整合了<code>Ribbon</code>，具有负载均衡的能力；</li><li>整合了<code>Hystrix</code>，具有熔断的能力。</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>1）<code>pom.xml</code>文件添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--添加Feign依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）配置启动类，添加<code>@EnableFeignClient</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &#123;&quot;com.landcode.land.service.user.service&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）定义一个<code>Feign</code>接口，通过<code>@FeignClient</code>（“服务名”）来指定调用哪个服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;land-hi&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITestHi</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hi&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hi</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述<code>ITestHi</code>接口调用<code>land-hi</code>服务，<code>hi</code>方法调用<code>land-hi</code>服务的<code>/hi</code>接口。</p><h2 id="自定义Feign配置类"><a href="#自定义Feign配置类" class="headerlink" title="自定义Feign配置类"></a>自定义Feign配置类</h2><p><code>Feign</code>也支持自定义配置，如下配置自定义重试机制，错误处理，拦截器demo。</p><ul><li><strong>代码配置方式</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义重试机制</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Retryer <span class="title function_">feignRetryer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//fegin提供的默认实现，最大请求次数为5，初始间隔时间为100ms，下次间隔时间1.5倍递增，重试间最大间隔时间为1s，</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Retryer</span>.Default();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误处理</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ErrorDecoder <span class="title function_">feignError</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (key, response) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (response.status() == <span class="number">400</span>) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;请求服务400参数错误,返回:&#123;&#125;&quot;</span>, response.body());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (response.status() == <span class="number">404</span>) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;请求服务404异常,返回:&#123;&#125;&quot;</span>, response.body());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其他异常交给Default去解码处理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ErrorDecoder</span>.Default().decode(key, response);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fegin 拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestInterceptor <span class="title function_">cameraSign</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template -&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果是get请求</span></span><br><span class="line">            <span class="keyword">if</span> (template.method().equals(Request.HttpMethod.GET.name())) &#123;</span><br><span class="line">                <span class="comment">//获取到get请求的参数</span></span><br><span class="line">                Map&lt;String, Collection&lt;String&gt;&gt; queries = template.queries();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是Post请求</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (template.method().equals(Request.HttpMethod.POST.name())) &#123;</span><br><span class="line">                <span class="comment">//获得请求body</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> template.requestBody().asString();</span><br><span class="line">                <span class="type">JSONPObject</span> <span class="variable">request</span> <span class="operator">=</span> JSON.parseObject(body, JSONPObject.class);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//根据请求参数生成的签名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="string">&quot;*******&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//放入url之后</span></span><br><span class="line">            template.query(<span class="string">&quot;sign&quot;</span>, sign);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//放入请求body中</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">newBody</span> <span class="operator">=</span> body + sign;</span><br><span class="line">            </span><br><span class="line">            template.body(Request.Body.encoded(newBody.getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，<code>FeignConfig</code>也可以无须定义在Spring容器中，直接在<code>@FeignClient</code>注解上使用也可以生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;hi&quot;, configuration = FeignConfig.class)</span></span><br></pre></td></tr></table></figure><ul><li><strong>属性配置方式</strong></li></ul><p>从<code>Spring Cloud Edgware</code>开始，<code>Feign</code>支持使用属性自定义配置。对于一个指定名称的<code>FeignClient</code>（例如该<code>FeignClient</code>的名称为<code>feignName</code> ），<code>Feign</code>支持如下配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">feignName:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span>  <span class="comment"># 相当于Request.Options</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span>     <span class="comment"># 相当于Request.Options</span></span><br><span class="line">        <span class="comment"># 配置Feign的日志级别，相当于代码配置方式中的Logger</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">full</span></span><br><span class="line">        <span class="comment"># Feign的错误解码器，相当于代码配置方式中的ErrorDecoder</span></span><br><span class="line">        <span class="attr">errorDecoder:</span> <span class="string">com.example.SimpleErrorDecoder</span></span><br><span class="line">        <span class="comment"># 配置重试，相当于代码配置方式中的Retryer</span></span><br><span class="line">        <span class="attr">retryer:</span> <span class="string">com.example.SimpleRetryer</span></span><br><span class="line">        <span class="comment"># 配置拦截器，相当于代码配置方式中的RequestInterceptor</span></span><br><span class="line">        <span class="attr">requestInterceptors:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">com.alanotes.FooRequestInterceptor</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">com.example.BarRequestInterceptor</span></span><br><span class="line">        <span class="attr">decode404:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>当然不建议配置<code>retryer</code>重试机制，Spring Cloud Camden以及之后的版本中，<code>Spring Cloud</code>关闭了<code>Feign</code>的重试，而是使用<code>Ribbon</code>的重试。如果自己再定义<code>Feign</code>的重试，可能会造成混乱。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringCloud系列之Feign&quot;&gt;&lt;a href=&quot;#SpringCloud系列之Feign&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud系列之Feign&quot;&gt;&lt;/a&gt;SpringCloud系列之Feign&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="微服务" scheme="https://imalan6.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="srpingcloud" scheme="https://imalan6.github.io/tags/srpingcloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud系列之Zuul</title>
    <link href="https://imalan6.github.io/2021/03/26/springcloud/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BZuul/"/>
    <id>https://imalan6.github.io/2021/03/26/springcloud/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BZuul/</id>
    <published>2021-03-26T13:11:21.000Z</published>
    <updated>2024-02-14T12:08:39.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud系列之Zuul"><a href="#SpringCloud系列之Zuul" class="headerlink" title="SpringCloud系列之Zuul"></a>SpringCloud系列之Zuul</h1><h2 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h2><p>服务网关是统一管理<code>API</code>的一个网络关口、通道，是整个微服务平台所有请求的唯一入口，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。</p><ul><li><p><strong>路由转发</strong>：接收所有外界请求，转发给微服务处理；</p></li><li><p><strong>过滤处理</strong>：对请求进行处理，比如权限校验、限流以及监控等。</p></li></ul><p><code>Zuul</code>是<code>Netflix OSS</code>中的一员，是一个基于<code>JVM</code>路由和服务端的负载均衡器。提供路由、监控、弹性、安全等方面的服务框架。<code>Zuul</code>能够与<code>Eureka</code>、<code>Ribbon</code>、<code>Hystrix</code>等组件配合使用。<code>Zuul</code>的核心是过滤器，通过这些过滤器可以扩展出很多功能，比如：</p><ul><li><strong>动态路由</strong></li></ul><p>动态地将客户端的请求转发到后端具体的服务，完成业务逻辑处理。</p><ul><li><strong>认证鉴权</strong></li></ul><p>对所有用户请求做身份认证，拒绝非法请求，提高整个系统安全性。</p><ul><li><strong>预警监控</strong></li></ul><p>可以对所有用户请求进行监控，记录详细的请求响应日志，实时统计当前系统访问量、状态。</p><ul><li><strong>负载均衡</strong></li></ul><p>为每种类型的请求分配容量并丢弃超过限额的请求。</p><ul><li><strong>静态资源处理</strong></li></ul><p>直接在<code>Zuul</code>处理静态资源并响应，而并非转发这些请求到内部集群中。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ul><li><strong>配置</strong></li></ul><p>1）<code>pom</code>文件添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）启动类加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZuulApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        SpringApplication.run(ZuulApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">land-zuul</span></span><br><span class="line"></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">land-user:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/user/**</span></span><br><span class="line">      <span class="attr">service-id:</span> <span class="string">land-user</span></span><br><span class="line">      <span class="attr">stripPrefix:</span> <span class="literal">false</span>  <span class="comment">#前缀方式映射-去掉前缀,不然访问需要/user前缀，比如访问/user/hello需要写成/user/user/hello.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span>  <span class="comment">#实现智能端点，查看路由信息，filters，路径：/actuator/routes，需要使用actuator，zuul已默认集成starter-actuator</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>   <span class="comment">#开启显示IP地址</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;</span>   <span class="comment">#eureka页面显示IP地址：端口号</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><hr><ul><li><strong>测试</strong></li></ul><p>启动<code>zuul</code>和<code>user</code>服务，访问：<a href="http://127.0.0.1:9000/user/hello">http://127.0.0.1:9000/user/hello</a> ，正常访问。</p><p><strong>需要注意：</strong>如果使用<code>springboot</code>部署<code>zuul</code>，并且添加了<code>starter-security</code>依赖，需要注销掉，不然会跳转到默认的登录页面。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">&lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">&lt;/dependency&gt;--&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/20/vmu1gxE4nliNWrk.png" alt="0.png"></p><p>这是因为在<code>SpringBoot</code>中，默认的<code>Spring Security</code>生效了，此时所有接口的访问都是被保护的。需要通过验证才能正常访问。<code>Spring Security</code>提供了一个默认的用户，用户名是user，而密码则是启动项目的时候自动生成的。如果不想注销依赖，可以有如下方法解决：</p><p><strong><code>SpringBoot1.x</code>以前，修改配置文件如下：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">basic:</span></span><br><span class="line"><span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong><code>SpringBoot2.x</code>及以后，添加配置类如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//配置不需要登陆验证</span></span><br><span class="line">        http.authorizeRequests().anyRequest().permitAll().and().logout().permitAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用基本配置"><a href="#常用基本配置" class="headerlink" title="常用基本配置"></a>常用基本配置</h2><ul><li><strong>配置path</strong></li></ul><p>上文中,我们配置的一个路由规则是这样的：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">land-user:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/user/**</span></span><br><span class="line">      <span class="attr">service-id:</span> <span class="string">land-user</span></span><br></pre></td></tr></table></figure><p>这里指定了<code>path</code>和<code>service-id</code>，可以简化一下，方式如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">service-id:</span> <span class="string">/user/**</span></span><br></pre></td></tr></table></figure><p><code>zuul.routes</code>后面是服务名，值是路径，上面这两种配置的方式都是可以的，下面这样更简洁。</p><ul><li><strong>配置url</strong></li></ul><p>同时指定<code>path</code>和<code>url</code>，例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">user-route:</span>     <span class="comment"># 该配置方式中，user-route 只是给路由一个名称，可以任意起名。</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">http://localhost:8001/</span>     <span class="comment"># 指定的 url</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/user/**</span>     <span class="comment"># url 对应的路径</span></span><br></pre></td></tr></table></figure><p>这样就可以将 <code>/user/**</code> 映射到 <code>http://localhost:8001/**</code>。</p><p>需要注意的是，使用这种方式配置的路由不会作为<code>HystrixCommand</code>执行，也不能使用<code>Ribbon</code>来负载均衡多个<code>url</code>。</p><p>同时指定<code>path</code>和<code>url</code>，并且不破坏<code>Zuul</code>的<code>Hystrix</code>、<code>Ribbon</code>特性。配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span> </span><br><span class="line">  <span class="attr">routes:</span> </span><br><span class="line">    <span class="attr">land-user:</span> </span><br><span class="line">      <span class="attr">url:</span> <span class="string">http://localhost:8001/</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/user/**</span></span><br><span class="line">      <span class="attr">service-id:</span> <span class="string">land-user</span></span><br><span class="line"><span class="attr">ribbon:</span> </span><br><span class="line">  <span class="attr">eureka:</span> </span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span>     <span class="comment"># 为 Ribbon 禁用 Eureka</span></span><br><span class="line"><span class="attr">land-user:</span> </span><br><span class="line">  <span class="attr">ribbon:</span> </span><br><span class="line">    <span class="attr">listOfServices:</span> <span class="string">localhost:8001,localhost:8002</span></span><br></pre></td></tr></table></figure><ul><li><strong>路由前缀</strong></li></ul><p>为所有路由规则增加前缀，配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">prefix:</span> <span class="string">/api</span></span><br></pre></td></tr></table></figure><p>比如之前访问路径是 <a href="http://localhost:9000/user/hello">http://localhost:9000/user/hello</a> ，配置了前缀之后，访问路径就变成了 <a href="http://localhost:9000/api/user/hello">http://localhost:9000/api/user/hello</a> 。</p><ul><li><strong>忽略指定服务</strong></li></ul><p>忽略服务可以使用<code>zuul.ignored-services</code>配置需要忽略的服务，多个用逗号分隔。例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span> </span><br><span class="line">  <span class="attr">ignored-services:</span> <span class="string">land-test,</span> <span class="string">land-hi</span></span><br></pre></td></tr></table></figure><p>这样<code>Zuul</code>就忽略掉了<code>land-test</code>和<code>land-hi</code>微服务，只代理其他微服务。</p><p>如果要忽略所有微服务，只路由指定微服务，可以将<code>zuul.ignored-services</code>设为<code>*</code>。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span> </span><br><span class="line">  <span class="attr">ignored-services:</span> <span class="string">&#x27;*&#x27;</span> <span class="comment"># 使用 &#x27;*&#x27; 可忽略所有微服务</span></span><br><span class="line">  <span class="attr">routes:</span> </span><br><span class="line">    <span class="attr">land-user:</span> <span class="string">/user/**</span></span><br></pre></td></tr></table></figure><ul><li><strong>通配符</strong></li></ul><p>不论是使用传统配置方式还是服务路由的配置方式，都需要使用通配符方式为每个路由定义匹配表达式。</p><table><thead><tr><th align="left">通配符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="left">?</td><td align="center">匹配任意单个字符</td></tr><tr><td align="left">*</td><td align="center">匹配任意数量的字符</td></tr><tr><td align="left">**</td><td align="center">匹配任意数量的自负，支持多级目录</td></tr></tbody></table><table><thead><tr><th align="left">url路径</th><th align="center">说明</th></tr></thead><tbody><tr><td align="left">&#x2F;user&#x2F;?</td><td align="center">可以匹配&#x2F;user&#x2F;之后的一个字符的路径，比如&#x2F;user&#x2F;a，&#x2F;user&#x2F;b</td></tr><tr><td align="left">&#x2F;user&#x2F;*</td><td align="center">可以匹配&#x2F;user&#x2F;之后任意字符的路径，比如&#x2F;user&#x2F;a，&#x2F;user&#x2F;aaa等</td></tr><tr><td align="left">&#x2F;user&#x2F;**</td><td align="center">可以匹配&#x2F;user&#x2F;*包含的内容之外，还可以匹配&#x2F;user&#x2F;a&#x2F;b等多级目录形式</td></tr></tbody></table><ul><li><strong>正则表达式路由映射</strong></li></ul><p>有时为了兼容不同版本的客户端程序，后端系统需要创建不同版本的微服务来应对，比如：<code>user-v1</code>，<code>user-v2</code>等。默认情况下，<code>Zuul</code>自动为服务创建的路由表达式会采用服务名作为前缀，比如针对上面的<code>user-v1</code>和<code>user-v2</code>会产生<code>/user-v1</code>和<code>/user-v2</code>两个路径表达式来映射，这样生成出来的表示式规则单一，不利于管理。通常的做法是以版本号作为路由前缀，比如<code>/v1/userservice/</code>。这种使用版本号为前缀的<code>url</code>路径，可以很方便地对服务进行版本归类和管理。</p><p>我们可以使用<code>Zuul</code>来自定义服务与路由映射关系，创建类似于<code>/v1/userserivce/**</code>的路由规则。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PatternServiceRouteMapper <span class="title function_">serviceRouteMapper</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 调用构造函数PatternServiceRouteMapper(String servicePattern, String routePattern)</span></span><br><span class="line">  <span class="comment">// servicePattern 指定微服务的正则</span></span><br><span class="line">  <span class="comment">// routePattern 指定路由正则</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PatternServiceRouteMapper</span>(<span class="string">&quot;(?&lt;name&gt;^.+)-(?&lt;version&gt;v.+$)&quot;</span>,<span class="string">&quot;$&#123;version&#125;/$&#123;name&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PatternServiceRouteMapper</code>对象可以让开发者通过正则表达式自定义服务与路由映射的关系。构造函数第一个参数用来匹配服务名称的正则表达式，第二个参数根据服务名内容转换出的表达式规则。当定义了<code>PatternServiceRouteMapper</code>之后，只要符合第一个参数定义规则的服务名，就会优先使用该实现构建表达式，如果没有匹配上还是会使用默认的路由映射规则，即采用完整服务名作为前缀的路径表达式。</p><ul><li><strong>Zuul + Ribbon + Hystrix 超时熔断</strong></li></ul><p><code>Ribbon</code>配置：</p><p>1）当使用了<code>Eureka</code>注册中心，<code>zuul.routes</code>配置使用<code>service-id</code>的时候，通过<code>ribbon.ReadTimeout</code>和<code>ribbon.SocketTimeout</code>配置；</p><p>2）当<code>zuul.routes</code>配置使用<code>url</code>的时候,通过<code>zuul.host.connect-timeout-millis</code>和<code>zuul.host.socket-timeout-millis</code>配置；</p><p>如果需要对指定服务进行特殊配置，方式如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;serviceName&gt;.ribbon.ReadTimeout</span>  <span class="string">#serviceName为服务名</span></span><br></pre></td></tr></table></figure><p><code>Hystrix</code>配置：</p><p>如果<code>Zuul</code>配置了熔断<code>Fallback</code>的话，熔断超时也需要配置，方式如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</span>=<span class="string">30000</span></span><br></pre></td></tr></table></figure><p><code>default</code>代表默认，如果需要为某个指定服务特殊配置熔断超时策略，方式如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix.command.&lt;serviceName&gt;.execution.isolation.thread.timeoutInMilliseconds</span>=<span class="string">30000</span></span><br></pre></td></tr></table></figure><p>如果想关闭<code>Hystrix</code>的重试机制可以通过下面的配置：</p><p>关闭全局重试机制：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">retryable:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>关闭某个服务的重试机制：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">land-user:</span></span><br><span class="line">      <span class="attr">retryable:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li><strong>Header设置</strong></li></ul><p>1）敏感Header设置</p><p>同一个系统中各个服务之间通过<code>Headers</code>来共享信息是没啥问题的，但是如果不想<code>Headers</code>中的一些敏感信息随着<code>HTTP</code>转发泄露出去话，需要在路由配置中指定一个忽略<code>Header</code>的清单。默认情况下，<code>Zuul</code>在请求路由时，会过滤<code>HTTP</code>请求头信息中的一些敏感信息，默认的敏感头信息通过<code>zuul.sensitiveHeaders</code>定义，包括<code>Cookie</code>、<code>Set-Cookie</code>、<code>Authorization</code>。配置的<code>sensitiveHeaders</code>可以用逗号分割。对指定路由的可以用下面进行配置:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对指定路由开启自定义敏感头</span></span><br><span class="line"><span class="attr">zuul.routes.[route].customSensitiveHeaders</span>=<span class="string">true </span></span><br><span class="line"><span class="attr">zuul.routes.[route].sensitiveHeaders</span>=<span class="string">[这里设置要过滤的敏感头]</span></span><br></pre></td></tr></table></figure><p>设置全局:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul.sensitiveHeaders</span>=<span class="string">[设置要过滤的敏感头]</span></span><br></pre></td></tr></table></figure><p>2）忽略Header设置</p><p>如果每一个路由都需要配置一些额外的敏感<code>Header</code>时，可以通过<code>zuul.ignoredHeaders</code>来统一设置需要忽略的<code>Header</code>。如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zuul.ignoredHeaders=[这里设置要忽略的Header]</span><br></pre></td></tr></table></figure><p>在默认情况下是没有这个配置的，如果项目中引入了<code>Spring Security</code>，那么<code>Spring Security</code>会自动加上这个配置，默认值为: <code>Pragma, Cache-Control, X-Frame-Options, X-Content-Type-Options, X-XSS-Protection, Expries</code>。</p><p>此时，如果还需要使用下游微服务的<code>Spring Security</code>的<code>Header</code>时，可以增加下面的设置:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul.ignoreSecurityHeaders</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><ul><li><strong>熔断处理fallback</strong></li></ul><p>当<code>Zuul</code>进行路由分发时，如果微服务没有启动，或者调用超时，<code>Zuul</code>可以使用一种降级功能，而不是将异常直接暴露出来。默认情况下，经过<code>Zuul</code>的请求都会使用<code>Hystrix</code>进行包裹，所以<code>Zuul</code>本身就具有断路器的功能<code>Zuul</code>，需要实现<code>ZuulFallbackProvider</code>接口。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HystrixFallbackConfig</span> <span class="keyword">implements</span> <span class="title class_">FallbackProvider</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRoute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//微服务配了路由的话，就用配置的名称</span></span><br><span class="line">        <span class="comment">//return &quot;land-user&quot;;</span></span><br><span class="line">        <span class="comment">//*表示为所有微服务提供回退</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;*&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ClientHttpResponse <span class="title function_">fallbackResponse</span><span class="params">(String route, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> HystrixTimeoutException) &#123;</span><br><span class="line">            <span class="keyword">return</span> response(HttpStatus.GATEWAY_TIMEOUT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.fallbackResponse();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClientHttpResponse <span class="title function_">fallbackResponse</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.response(HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClientHttpResponse <span class="title function_">response</span><span class="params">(<span class="keyword">final</span> HttpStatus status)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientHttpResponse</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> HttpStatus <span class="title function_">getStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">return</span> status;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRawStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">return</span> status.value();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getStatusText</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">return</span> status.getReasonPhrase();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> InputStream <span class="title function_">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(<span class="string">&quot;服务不可用，请稍后再试。&quot;</span>.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> HttpHeaders <span class="title function_">getHeaders</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// headers设定</span></span><br><span class="line">                <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">                <span class="comment">// MediaType mt = new MediaType(&quot;application&quot;, &quot;json&quot;, Charset.forName(&quot;UTF-8&quot;));</span></span><br><span class="line">                <span class="comment">// headers.setContentType(mt);</span></span><br><span class="line">                headers.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">                <span class="keyword">return</span> headers;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>user</code>服务不可用时，访问返回结果如下：</p><p><img src="https://i.loli.net/2021/03/20/QwRXJf1lFWetrOy.png" alt="3.png"></p><h2 id="请求过滤"><a href="#请求过滤" class="headerlink" title="请求过滤"></a>请求过滤</h2><p>如果需要通过网关实现一些诸如过滤，权限验证等功能，就需要用到<code>Zuul</code>的请求过滤的功能。<code>ZuulFilter</code>类似于一个拦截器，会把请求拦截下来，然后做相应处理，最后决定是否放行。</p><p><code>Zuul</code>大部分功能都是通过过滤器来实现的。<code>Zuul</code>中定义了四种标准过滤器类型，这些过滤器类型对应于请求的典型生命周期：</p><ul><li><strong>PRE</strong>：这种过滤器在请求被路由之前调用。可以利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。</li><li><strong>ROUTING</strong>：这种过滤器将请求路由到微服务。用于构建发送给微服务的请求，并使用<code>Apache HttpClient</code>或<code>Netflix Ribbon</code>构建和发送原始HTTP请求的位置。</li><li><strong>POST</strong>：请求在路由到微服务之后执行。示例包括向响应添加标准<code>Http</code>标头、收集统计信息和指标、以及将响应从源传输到客户端。</li><li><strong>ERROR</strong>：过滤器在其中一个阶段发生错误时执行。</li></ul><p>除了默认的过滤器类型，<code>Zuul</code>还允许我们创建自定义过滤器类型。例如，自定义一个<code>Static</code>类型的过滤器，它直接在<code>Zuul</code>中生成响应，而不是将请求转发到后端的微服务。<code>Zuul</code>请求的生命周期如下图所示，详细描述了各种类型的过滤器执行顺序。</p><p><img src="https://i.loli.net/2021/03/20/ztoJUHyAuTO5ibW.png" alt="1.png"></p><p>现在使用<code>Zuul</code>过滤器模拟一个对请求进行权限认证的功能，首先自定义一个过滤器并继承<code>ZuulFilter</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZuulFilterConfig</span> <span class="keyword">extends</span> <span class="title class_">ZuulFilter</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 过滤器类型，pre表示在请求路由之前进行拦截</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">filterType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;pre&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤器的执行顺序。当请求在一个阶段的时候存在多个过滤器时，需要根据该方法的返回值依次执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">filterOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 值越小执行顺行越靠前</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定过滤器是否生效</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 默认此类过滤器时false，不开启的，需要改为true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RequestContext</span> <span class="variable">ctx</span> <span class="operator">=</span> RequestContext.getCurrentContext();</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ctx.getRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;access-token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(token.trim()) &#123;</span><br><span class="line">            ctx.setSendZuulResponse(<span class="literal">false</span>);</span><br><span class="line">            ctx.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">            ctx.addZuulResponseHeader((<span class="string">&quot;content-type&quot;</span>), <span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">            ctx.setResponseBody(<span class="string">&quot;拒绝访问&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 否则正常执行业务逻辑.....</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>Zuul</code>，不提供<code>access-token</code>参数访问服务，结果如下：</p><p><img src="https://i.loli.net/2021/03/20/tUwpLsmnYj6khyX.png" alt="2.png"></p><h5 id="方法说明："><a href="#方法说明：" class="headerlink" title="方法说明："></a>方法说明：</h5><ul><li><code>filterType()</code>：返回值为过滤器的类型，过滤器的类型决定了过滤器在哪个生命周期执行，上面代码中返回的是<code>pre</code>，表示是在路由之前执行过滤，其他可选值还有<code>post</code>，<code>error</code>，<code>route</code>和<code>static</code>，也可以自定义。</li><li><code>filterOrder()</code>：返回过滤器的执行顺序，当有多个过滤器时，这个方法定义执行顺序。</li><li><code>shouldFilter()</code>：这个方法用来判断这个过滤器是否执行，<code>true</code>就是执行，在实际使用中可以根据当前请求地址来决定要不要执行这个过滤器，这里为了测试，直接返回<code>true</code>了。</li><li><code>run()</code>：过滤器的具体业务逻辑，上面例子中，有<code>access-token</code>参数的请求放行，否则拦截下来。首先需要设置<code>ctx.setSendZuulResponse(false);</code>表示这个请求就不进行路由了，然后再设置<code>http</code>状态码和具体返回的<code>body</code>内容。在实际项目中，在<code>run</code>方法中可能是先获取用户对象，然后做权限判断等，并根据具体的业务具体实现。<code>run</code>方法的返回值在目前的版本中没有任何意义，可随意处理。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringCloud系列之Zuul&quot;&gt;&lt;a href=&quot;#SpringCloud系列之Zuul&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud系列之Zuul&quot;&gt;&lt;/a&gt;SpringCloud系列之Zuul&lt;/h1&gt;&lt;h2 id=&quot;服</summary>
      
    
    
    
    <category term="微服务" scheme="https://imalan6.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="srpingcloud" scheme="https://imalan6.github.io/tags/srpingcloud/"/>
    
    <category term="网关" scheme="https://imalan6.github.io/tags/%E7%BD%91%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud系列之Eureka</title>
    <link href="https://imalan6.github.io/2021/03/23/springcloud/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BEureka/"/>
    <id>https://imalan6.github.io/2021/03/23/springcloud/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BEureka/</id>
    <published>2021-03-23T15:21:44.000Z</published>
    <updated>2024-02-14T11:32:17.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud系列之Eureka"><a href="#SpringCloud系列之Eureka" class="headerlink" title="SpringCloud系列之Eureka"></a>SpringCloud系列之Eureka</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><strong>服务治理</strong></li></ul><p>服务治理是微服务架构中最为核心和基础的模块，它主要用来实现各个微服务实例的自动化注册和发现。</p><p>1）服务注册</p><p>在服务治理框架中，通常都会构建一个注册中心，每个服务单元向注册中心登记自己提供的服务，包括服务的主机与端口号、服务版本号、通讯协议等一些附加信息。注册中心按照服务名分类组织服务清单，同时还<strong>需要以心跳检测的方式去监测清单中的服务是否可用</strong>，若不可用需要从服务清单中剔除，以达到排除故障服务的效果。</p><p>2）服务发现</p><p>在服务治理框架下，服务间的调用不再通过指定具体的实例地址来实现，而是通过服务名发起请求调用实现。服务调用方通过服务名从服务注册中心的服务清单中获取服务实例的列表清单，通过指定的负载均衡策略取出一个服务实例位置来进行服务调用。</p><ul><li><strong>Eureka介绍</strong></li></ul><p>Spring Cloud Eureka是<code>Spring Cloud Netflix</code>微服务套件中的一部分，它基于<code>Netflix Eureka</code>做了二次封装。主要负责完成微服务架构中的服务治理功能。</p><p><code>Spirng Cloud Eureka</code>使用<code>Netflix Eureka</code>来<strong>实现服务注册与发现</strong>。它既包含了服务端组件，也包含了客户端组件，并且服务端与客户端均采用java编写，所以<code>Eureka</code>主要适用于通过java实现的分布式系统，或是JVM兼容语言构建的系统。<code>Eureka</code>的服务端提供了较为完善的<code>REST API</code>，所以<code>Eureka</code>也支持将非java语言实现的服务纳入到<code>Eureka</code>服务治理体系中来，只需要其他语言平台自己实现<code>Eureka</code>的客户端程序。</p><p>1）Eureka服务端</p><p><code>Eureka</code>服务端，即服务注册中心。它同其他服务注册中心一样，支持高可用配置。依托于强一致性提供良好的服务实例可用性，可以应对多种不同的故障场景。</p><p><strong>Eureka服务端支持集群模式部署</strong>，当集群中有分片发生故障的时候，<code>Eureka</code>会自动转入自我保护模式。它允许在分片发生故障的时候继续提供服务的发现和注册，当故障分配恢复时，集群中的其他分片会把他们的状态再次同步回来。集群中的的不同服务注册中心通过异步模式互相复制各自的状态，这也意味着在给定的时间点每个实例关于所有服务的状态可能存在不一致的现象。</p><p>2）Eureka客户端</p><p><code>Eureka</code>客户端，主要处理服务的注册和发现。客户端服务通过注册和参数配置的方式，嵌入在客户端应用程序的代码中。在应用程序启动时，<code>Eureka</code>客户端向服务注册中心注册自身提供的服务，<strong>并周期性的发送心跳来更新它的服务租约</strong>。同时，他也能从服务端查询当前注册的服务信息<strong>并把它们缓存到本地并周期性地刷新</strong>服务状态。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h4 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h4><ul><li><strong>服务器端</strong></li></ul><p>1）pom文件添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）启动类加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaApplication</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）application.xml配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">land-eureka</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 是否要注册到其他Eureka Server实例</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 是否要从其他Eureka Server实例获取数据</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span> </span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><hr><ul><li><strong>客户端</strong></li></ul><p>1）添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderUserApplication</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   SpringApplication.run(ProviderUserApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：早期的版本（Dalston及更早版本）还需在启动类上添加注解<code>@EnableDiscoveryClient</code> 或<code>@EnableEurekaClient</code> ，从Edgware开始，该注解可省略。</p><p>3）添加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 指定注册到eureka server上的服务名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">land-user</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 指定eureka server地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 是否注册IP到eureka server。如不指定或设为false，会注册主机名到eureka server</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><ul><li><strong>测试</strong></li></ul><p>启动<code>Eureka</code>服务端，启动<code>land-user</code>服务，使用浏览器打开 <a href="http://localhost:8761/">http://localhost:8761/</a> 访问<code>eureka</code>管理页面，即可查看服务信息。</p><p><img src="https://i.loli.net/2021/03/18/JdD6XaFoQrHhBm8.png" alt="0.png"></p><h4 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h4><p>在生产环境中，通常需要配置3台及以上的服务注册中心来提高可用性，配置原理都一样，将注册中心分别指向其它的注册中心。这里介绍三台集群的配置情况，其实和双节点的注册中心类似，每台注册中心分别又指向其它两个节点即可，使用<code>application.yml</code>来配置。</p><p>三个配置文件，分别如下：</p><p>application-sever1.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">land-eureka</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">sever1</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">sever1</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://sever2:8762/eureka/,http://sever3:8763/eureka/</span></span><br></pre></td></tr></table></figure><p>application-sever2.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">land-eureka2</span>  <span class="comment">#不能重复</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">sever2</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8762</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">sever2</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://sever1:8761/eureka/,http://sever3:8763/eureka/</span></span><br></pre></td></tr></table></figure><p>application-sever3.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">land-eureka3</span><span class="comment">#不能重复</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">sever3</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8763</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">sever3</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://sever1:8761/eureka/,http://sever2:8762/eureka/</span></span><br></pre></td></tr></table></figure><p>修改本机<code>hosts</code>文件，添加<code>sever1</code>，<code>sever2</code>，<code>sever3</code>解析</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1sever1</span><br><span class="line">127.0.0.1sever2</span><br><span class="line">127.0.0.1sever3</span><br></pre></td></tr></table></figure><p>然后在配置文件<code>application.yml</code>中<code>profiles</code>，<code>active</code>配置项分别指定<code>application-sever1.yml</code>，<code>application-sever2.yml</code>，<code>application-sever3.yml</code>启动服务即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用的配置文件名</span></span><br><span class="line"><span class="attr">profiles:</span></span><br><span class="line"><span class="attr">active:</span> <span class="string">sever1</span>  <span class="comment">#分别指定sever1,sever2,sever3</span></span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://i.loli.net/2021/03/18/E1GskMofPTBQlyx.png" alt="1.png"></p><p>如图是<code>Eureka</code>集群的工作原理，包括：</p><p>1）Application Service，服务提供者；</p><p>2）Application Client，服务消费者；</p><p>3）Make Remote Call调用<code>RESTful API</code>；</p><p>4）us-east-1c、us-east-1d等都是<code>Availability Zone</code>，它们都属于<code>us-east-1</code>这个<code>region</code>。</p><p>由图可知，<code>Eureka</code>包含两个组件：<code>Eureka Server</code>和<code>Eureka Client</code>，它们的作用如下：</p><p>1）<code>Eureka Server</code>提供服务发现的能力，各个微服务启动时，会向<code>Eureka Server</code>注册自己的信息（例如IP、端口、微服务名称等），<code>Eureka Server</code>会存储这些信息；</p><p>2）<code>Eureka Client</code>是一个Java客户端，用于简化与<code>Eureka Server</code>的交互；</p><p>3）微服务启动后，会周期性（<strong>默认30秒</strong>）地向<code>Eureka Server</code>发送心跳以续约自己的“租期”；</p><p>4）如果<code>Eureka Server</code>在一定时间内没有接收到某个微服务实例的心跳，<code>Eureka Server</code>将会注销该服务实例（<strong>默认90秒</strong>）；</p><p>5）默认情况下，<code>Eureka Server</code>同时也是<code>Eureka Client</code>。多个<code>Eureka Server</code>实例，互相之间通过增量复制的方式，来实现服务注册表中数据的同步。<code>Eureka Server</code>默认保证在90秒内，<code>Eureka Server</code>集群内的所有实例中的数据达到一致；</p><p>6）<code>Eureka Client</code>会<strong>缓存服务注册表中的信息</strong>。这样，微服务无需每次请求都查询<code>Eureka Server</code>，从而降低了<code>Eureka Server</code>的压力；另外，即使<code>Eureka Server</code>所有节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者并完成调用。</p><p><code>Eureka</code>通过心跳检查、客户端缓存等机制，提高了系统的可用性、灵活性以及可伸缩性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringCloud系列之Eureka&quot;&gt;&lt;a href=&quot;#SpringCloud系列之Eureka&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud系列之Eureka&quot;&gt;&lt;/a&gt;SpringCloud系列之Eureka&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="微服务" scheme="https://imalan6.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="srpingcloud" scheme="https://imalan6.github.io/tags/srpingcloud/"/>
    
    <category term="服务注册" scheme="https://imalan6.github.io/tags/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud系列之Admin</title>
    <link href="https://imalan6.github.io/2021/03/18/springcloud/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BAdmin/"/>
    <id>https://imalan6.github.io/2021/03/18/springcloud/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BAdmin/</id>
    <published>2021-03-18T15:11:34.000Z</published>
    <updated>2024-02-14T11:32:17.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud系列之Admin"><a href="#SpringCloud系列之Admin" class="headerlink" title="SpringCloud系列之Admin"></a>SpringCloud系列之Admin</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Spring Boot Admin</code>主要用于管理和监控<code>SpringBoot</code>应用程序。被监控的应用程序被看作是一个客户端点，以<code>http</code>方式或者使用注册中心直接注册到<code>Spring Boot Admin Server</code>上。注册成功后，可以通过<code>Spring Boot Admin</code>提供的<code>UI</code>界面，可以轻松监控查看<code>Actuator</code>端点的监控信息。监控信息挺多，列举部分常见功能如下：</p><ul><li>显示健康状况</li><li>显示详细信息，例如<ul><li><code>JVM</code>和内存指标</li><li><code>micrometer.io</code>指标</li><li>数据源指标</li><li>缓存指标</li></ul></li><li>查看<code>JVM</code>系统和环境属性</li><li>查看<code>Spring Boot</code>配置属性</li><li>轻松的日志级管理</li><li>与<code>JMX-beans</code>交互</li><li>查看线程转储</li><li>查看<code>http</code>跟踪</li><li>下载<code>heapdump</code></li></ul><h2 id="单服务监控"><a href="#单服务监控" class="headerlink" title="单服务监控"></a>单服务监控</h2><ul><li><strong>Server端配置</strong></li></ul><p>1）添加<code>pom</code>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）启动类添加注解<code>@EnableAdminServer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAdminServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LandAdminApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(LandAdminApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>客户端配置</strong></li></ul><p>1）添加<code>pom</code>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）添加配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  boot:</span><br><span class="line">    admin:</span><br><span class="line">      client:</span><br><span class="line">        url: http://localhost:8000  #Admin Server地址 </span><br><span class="line">        </span><br><span class="line">#actuator启用监控</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;  #开放所有端点health，info，metrics，通过actuator/端点名，就可以获取对应的信息。如果不配置，默认只打开health和info端点</span><br></pre></td></tr></table></figure><p>需要配置<code>admin server</code>的地址，还需要打开<code>actuator</code>端点。</p><ul><li><strong>测试</strong></li></ul><p>启动<code>Admin</code>服务和需要监控的微服务，访问 <a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a> ，显示如下：</p><p><img src="https://i.loli.net/2021/03/25/mypHBKzeMuF9Wwr.png" alt="0.png"></p><p>点击查看服务详细信息如下：</p><p><img src="https://i.loli.net/2021/03/25/yc1L3TR8JahBg7k.png" alt="1.png"></p><p><code>Spring Boot Admin</code>以图形化方式展示了被监控服务的各项信息，这些信息大多都来自于<code>Spring Boot Actuator</code>提供的接口。</p><h2 id="微服务监控"><a href="#微服务监控" class="headerlink" title="微服务监控"></a>微服务监控</h2><p>如果只是单个或少量的<code>Spring Boot</code>应用，采用上面直接在端点完成配置的方式就可以了。但如果是微服务系统，且后端有很多微服务的话，采用上面的配置方式就显得过于复杂和笨拙。这时可以借助注册中心<code>Eureka</code>来完成，让<code>Spring Boot Admin</code>自动从注册中心抓取应用的相关信息。</p><p>如果使用<code>Spring Cloud</code>的服务发现功能完成监控抓取，服务端点就不需要再单独添加<code>Admin Client</code>依赖，只需要<code>Admin Serve</code>r就可以了，其它内容会自动进行配置。</p><p>1）客户端和<code>Admin</code>服务端都完成<code>Eureka</code>配置，详见 <a href="springcloud/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BEureka.md">SpringCloud系列之Eureka</a> 。</p><p>2）启动各个服务，访问 <a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a> ，显示如下：</p><p><img src="https://i.loli.net/2021/03/25/gJxaQ7lyEU9kDZY.png" alt="2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringCloud系列之Admin&quot;&gt;&lt;a href=&quot;#SpringCloud系列之Admin&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud系列之Admin&quot;&gt;&lt;/a&gt;SpringCloud系列之Admin&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="微服务" scheme="https://imalan6.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="srpingcloud" scheme="https://imalan6.github.io/tags/srpingcloud/"/>
    
    <category term="监控" scheme="https://imalan6.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud系列之Actuator</title>
    <link href="https://imalan6.github.io/2021/03/12/springcloud/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BActuator/"/>
    <id>https://imalan6.github.io/2021/03/12/springcloud/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BActuator/</id>
    <published>2021-03-12T08:12:24.000Z</published>
    <updated>2024-02-14T11:32:17.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud系列之Actuator"><a href="#SpringCloud系列之Actuator" class="headerlink" title="SpringCloud系列之Actuator"></a>SpringCloud系列之Actuator</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>微服务系统通常是分布式部署的，大部分服务都运行在不同的机器上，彼此通过服务接口交互调用，业务会经过多个微服务的处理和传递，如果期间出现了异常需要快速定位，就需要对微服务的状态进行实时监控。</p><p><code>spring-boot-starter-actuator</code>，这个模块可以自动为<code>Spring Boot</code>创建的应用构建一系列的用于监控的端点。<code>Actuator</code>是<code>Spring Boot</code>提供的对应用系统的自省和监控的集成功能，可以查看应用配置的详细信息，例如自动化配置信息、创建的<code>Spring beans</code>以及一些环境属性等。使用<code>Actuator</code>可以很方便地对微服务状况进行监控。</p><h2 id="监控端点"><a href="#监控端点" class="headerlink" title="监控端点"></a>监控端点</h2><p><code>Actuator</code>监控端点分为原生端点和用户自定义端点。自定义端点可以让用户自定义一些比较关心的指标，在运行期进行监控。而原生端点是由<code>actuator</code>提供的<code>web</code>接口，用来了解服务运行时的内部状况。原生端点可以分成三类：</p><ul><li>应用配置类：用于查看服务在运行时的静态信息，比如自动配置信息，<code>Spring Bean</code>信息、配置文件信息、环境信息、请求映射等；</li><li>度量指标类：主要是服务运行时的动态信息，比如堆栈、请求链、健康指标、<code>metrics</code>信息等；</li><li>操作控制类：主要是指<code>shutdown</code>，用户可以发送请求关闭应用的监控功能。</li></ul><p><code>Actuator</code>提供了13个接口，如下表所示：</p><table><thead><tr><th align="center">HTTP方法</th><th align="center">路径</th><th align="center">描述</th><th align="center">鉴权</th></tr></thead><tbody><tr><td align="center">GET</td><td align="center">&#x2F;autoconfig</td><td align="center">查看自动配置的使用情况</td><td align="center">true</td></tr><tr><td align="center">GET</td><td align="center">&#x2F;configprops</td><td align="center">查看配置属性，包括默认配置</td><td align="center">true</td></tr><tr><td align="center">GET</td><td align="center">&#x2F;beans</td><td align="center">查看bean及其关系列表</td><td align="center">true</td></tr><tr><td align="center">GET</td><td align="center">&#x2F;dump</td><td align="center">打印线程栈</td><td align="center">true</td></tr><tr><td align="center">GET</td><td align="center">&#x2F;env</td><td align="center">查看所有环境变量</td><td align="center">true</td></tr><tr><td align="center">GET</td><td align="center">&#x2F;env&#x2F;{name}</td><td align="center">查看具体变量值</td><td align="center">true</td></tr><tr><td align="center">GET</td><td align="center">&#x2F;health</td><td align="center">查看应用健康指标</td><td align="center">false</td></tr><tr><td align="center">GET</td><td align="center">&#x2F;info</td><td align="center">查看应用信息</td><td align="center">false</td></tr><tr><td align="center">GET</td><td align="center">&#x2F;mappings</td><td align="center">查看所有url映射</td><td align="center">true</td></tr><tr><td align="center">GET</td><td align="center">&#x2F;metrics</td><td align="center">查看应用基本指标</td><td align="center">true</td></tr><tr><td align="center">GET</td><td align="center">&#x2F;metrics&#x2F;{name}</td><td align="center">查看具体指标</td><td align="center">true</td></tr><tr><td align="center">POST</td><td align="center">&#x2F;shutdown</td><td align="center">关闭应用</td><td align="center">true</td></tr><tr><td align="center">GET</td><td align="center">&#x2F;trace</td><td align="center">查看基本追踪信息</td><td align="center">true</td></tr></tbody></table><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>1）加入<code>pom</code>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启用监控</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span>  <span class="comment">#开放所有端点health，info，metrics，通过actuator/端点名，就可以获取对应的信息。如果不配置，默认只打开health和info端点</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">always</span>  <span class="comment">#未开启actuator/health时，我们获取到的信息是&#123;&quot;status&quot;:&quot;UP&quot;&#125;，status的值还有可能是 DOWN。开启后打印详细信息</span></span><br></pre></td></tr></table></figure><p>3）启动服务，输入 <a href="http://localhost:8081/actuator">http://localhost:8081/actuator</a> ，查看端点信息如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_links&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;self&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;archaius&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/archaius&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;auditevents&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/auditevents&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;beans&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/beans&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;caches-cache&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/caches/&#123;cache&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;caches&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/caches&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;health&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/health&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;health-component-instance&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/health/&#123;component&#125;/&#123;instance&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;health-component&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/health/&#123;component&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;conditions&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/conditions&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;configprops&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/configprops&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/env&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;env-toMatch&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/env/&#123;toMatch&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/info&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;loggers&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/loggers&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;loggers-name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/loggers/&#123;name&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;heapdump&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/heapdump&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;threaddump&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/threaddump&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;metrics-requiredMetricName&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/metrics/&#123;requiredMetricName&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;metrics&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/metrics&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;scheduledtasks&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/scheduledtasks&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;httptrace&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/httptrace&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/mappings&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;refresh&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/refresh&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;features&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/features&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;service-registry&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/service-registry&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;jolokia&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/jolokia&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;hystrix.stream&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://127.0.0.1:8801/actuator/hystrix.stream&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;templated&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>4）输入<a href="http://127.0.0.1:8801/actuator/health%EF%BC%8C%E6%9F%A5%E7%9C%8B%60health%60%E7%AB%AF%E7%82%B9%E4%BF%A1%E6%81%AF%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:8801/actuator/health，查看`health`端点信息如下：</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="string">&quot;UP&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;diskSpace&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="string">&quot;UP&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span><span class="number">124945166336</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;free&quot;</span><span class="punctuation">:</span><span class="number">738893824</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;threshold&quot;</span><span class="punctuation">:</span><span class="number">10485760</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;refreshScope&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="string">&quot;UP&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;discoveryComposite&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="string">&quot;UP&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;discoveryClient&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="string">&quot;UP&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;services&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">                        <span class="punctuation">]</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;eureka&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;Eureka discovery client has not yet successfully connected to a Eureka server&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="string">&quot;UP&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;applications&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;hystrix&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="string">&quot;UP&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringCloud系列之Actuator&quot;&gt;&lt;a href=&quot;#SpringCloud系列之Actuator&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud系列之Actuator&quot;&gt;&lt;/a&gt;SpringCloud系列之Actuat</summary>
      
    
    
    
    <category term="微服务" scheme="https://imalan6.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="srpingcloud" scheme="https://imalan6.github.io/tags/srpingcloud/"/>
    
    <category term="监控" scheme="https://imalan6.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Thread Dump日志分析案例</title>
    <link href="https://imalan6.github.io/2021/02/12/jvm/ThreadDump%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/"/>
    <id>https://imalan6.github.io/2021/02/12/jvm/ThreadDump%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/</id>
    <published>2021-02-12T10:32:11.000Z</published>
    <updated>2024-02-14T12:06:21.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Thread-Dump日志分析案例"><a href="#Thread-Dump日志分析案例" class="headerlink" title="Thread Dump日志分析案例"></a>Thread Dump日志分析案例</h1><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>Thread Dump 文件里，值得关注的线程状态有：</p><p>1）死锁，<strong>Deadlock（重点关注）</strong> </p><p>2）执行中，Runnable  </p><p>3）等待资源，<strong>Waiting on condition（重点关注）</strong> </p><p>4）等待获取监视器，<strong>Waiting on monitor entry（重点关注）</strong></p><p>5）暂停，Suspended</p><p>6）对象等待中，Object.wait() 或 TIMED_WAITING</p><p>7）阻塞，<strong>Blocked（重点关注）</strong> </p><p>8）停止，Parked</p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h4 id="日志组成要素"><a href="#日志组成要素" class="headerlink" title="日志组成要素"></a>日志组成要素</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&quot;resin-22129&quot; daemon prio=10 tid=0x00007fbe5c34e000 nid=0x4cb1 waiting on condition [0x00007fbe4ff7c000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">    at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:315)</span><br><span class="line">    at com.caucho.env.thread2.ResinThread2.park(ResinThread2.java:196)</span><br><span class="line">    at com.caucho.env.thread2.ResinThread2.runTasks(ResinThread2.java:147)</span><br><span class="line">    at com.caucho.env.thread2.ResinThread2.run(ResinThread2.java:118)</span><br><span class="line"></span><br><span class="line">&quot;Timer-20&quot; daemon prio=10 tid=0x00007fe3a4bfb800 nid=0x1a31 in Object.wait() [0x00007fe3a077a000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">    at java.lang.Object.wait(Native Method)</span><br><span class="line">    - waiting on &lt;0x00000006f0620ff0&gt; (a java.util.TaskQueue)</span><br><span class="line">    at java.util.TimerThread.mainLoop(Timer.java:552)</span><br><span class="line">    - locked &lt;0x00000006f0620ff0&gt; (a java.util.TaskQueue)</span><br><span class="line">    at java.util.TimerThread.run(Timer.java:505)</span><br></pre></td></tr></table></figure><p>以上依次是：</p><p>1）<code>&quot;resin-22129&quot;</code><strong>线程名称：</strong>如果使用<code>java.lang.Thread</code>类生成一个线程的时候，线程名称为 Thread-(数字) 的形式，这里是<code>resin</code>生成的线程；</p><p>2）<code>daemon</code><strong>线程类型：</strong>线程分为守护线程 (<code>daemon</code>) 和非守护线程 (<code>non-daemon</code>) 两种，通常都是守护线程；</p><p>3）<code>prio=10</code><strong>线程优先级：</strong>默认为5，数字越大优先级越高；</p><p>4）<code>tid=0x00007fbe5c34e000</code><strong>JVM线程的id：</strong>JVM 内部线程的唯一标识，通过<code>java.lang.Thread.getId()</code>获取，通常用自增的方式实现；</p><p>5）<code>nid=0x4cb1</code><strong>系统线程id：</strong>对应的系统线程id（<code>Native Thread ID</code>)，可以通过 top 命令进行查看，现场id是十六进制的形式；</p><p>6）<code>waiting on condition</code><strong>系统线程状态：</strong>这里是系统的线程状态；</p><p>7）<code>[0x00007fbe4ff7c000]</code><strong>起始栈地址：</strong>线程堆栈调用的其实内存地址；</p><p>8）<code>java.lang.Thread.State: WAITING (parking)</code><strong>JVM线程状态：</strong>这里标明了线程在代码级别的状态。</p><p>9）线程调用栈信息：下面就是当前线程调用的详细栈信息，用于代码的分析。堆栈信息应该从下向上解读，因为程序调用的顺序是从下向上的。</p><h4 id="案例一：Waiting-to-lock-和-Blocked"><a href="#案例一：Waiting-to-lock-和-Blocked" class="headerlink" title="案例一：Waiting to lock 和 Blocked"></a>案例一：Waiting to lock 和 Blocked</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;RMI TCP Connection(267865)-172.16.5.25&quot; daemon prio=10 tid=0x00007fd508371000 nid=0x55ae waiting for monitor entry [0x00007fd4f8684000]</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at org.apache.log4j.Category.callAppenders(Category.java:201)</span><br><span class="line">- waiting to lock &lt;0x00000000acf4d0c0&gt; (a org.apache.log4j.Logger)</span><br><span class="line">at org.apache.log4j.Category.forcedLog(Category.java:388)</span><br><span class="line">at org.apache.log4j.Category.log(Category.java:853)</span><br><span class="line">at org.apache.commons.logging.impl.Log4JLogger.warn(Log4JLogger.java:234)</span><br><span class="line">at com.tuan.core.common.lang.cache.remote.SpyMemcachedClient.get(SpyMemcachedClient.java:110)</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>1）线程状态是 <strong>Blocked</strong>，阻塞状态。说明线程等待资源超时了。</p><p>2）“<code>waiting to lock &lt;0x00000000acf4d0c0&gt;</code>” 指线程在等待给<code>0x00000000acf4d0c0</code>这个地址上锁。</p><p>3）在<code>dump</code>日志里查找字符串<code>0x00000000acf4d0c0</code>，发现有大量线程都在等待给这个地址上锁。如果能在日志里找到谁获得了这个锁（如<code>locked &lt; 0x00000000acf4d0c0 &gt;</code>），就可以顺藤摸瓜了。</p><p>4）“<strong>waiting for monitor entry</strong>” 说明此线程通过<code>synchronized(obj) &#123;……&#125;</code>申请进入了临界区，从而进入了下图1中的 “<code>Entry Set</code>” 队列，但该 obj 对应的<code>monitor</code>被其他线程拥有，所以本线程在<code>Entry Set</code>队列中等待。</p><p>5）第一行里，”<code>RMI TCP Connection(267865)-172.16.5.25</code>“是 Thread Name 。<code>tid</code>指<code>Java Thread id</code>。<code>nid</code>指<code>native</code>线程的 id。<code>prio</code>是线程优先级。[0x00007fd4f8684000] 是线程栈起始地址。</p><p><strong>Dump文件中的线程状态含义及注意事项</strong>：</p><ul><li>Deadlock：死锁线程，一般指多个线程调用间，进入相互资源占用，导致一直等待无法释放的情况。</li><li>Runnable：一般指该线程正在执行状态中，该线程占用了资源，正在处理某个请求，有可能正在传递SQL到数据库执行，有可能在对某个文件操作，有可能进行数据类型等转换。</li><li>Waiting on condition：等待资源，或等待某个条件的发生，具体原因需结合<code>stack trace</code>来分析。<ul><li>如果堆栈信息明确是应用代码，则证明该线程正在等待资源。一般是大量读取某资源，且该资源采用了资源锁的情况下，线程进入等待状态，等待资源的读取，也可能是正在等待其他线程的执行等。</li><li>如果发现有大量的线程都在处在<code>Wait on condition</code>，从线程栈看，正等待网络读写，这可能是网络瓶颈的一个征兆。可能是由于网络阻塞导致线程无法执行：<ul><li>一种情况是网络非常忙，几乎消耗了所有的带宽，仍然有大量数据等待网络读写；</li><li>另一种情况也可能是网络空闲，但由于路由等问题，导致包无法正常的到达。</li></ul></li><li>另外一种出现<code>Wait on condition</code>的常见情况是该线程在<code>sleep</code>，等待<code>sleep</code>的时间到了时候，将被唤醒。</li></ul></li><li>Blocked：线程阻塞，是指当前线程执行过程中，所需要的资源长时间等待却一直未能获取到，被容器的线程管理器标识为阻塞状态，可以理解为等待资源超时的线程。</li><li>Waiting for monitor entry 和 in Object.wait()：<code>Monitor</code>是 Java 中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者<code>class</code>的锁。每一个对象都有且仅有一个<code>monitor</code>。从下图1中可以看出，每个<code>Monitor</code>在某个时刻，只能被一个线程拥有，该线程就是 “<code>Active Thread</code>”，而其它线程都是 “<code>Waiting Thread</code>”，分别在两个队列 “<code>Entry Set</code>” 和 “<code>Wait Set</code>” 里面等候。在 “<code>Entry Set</code>” 中等待的线程状态是 “<code>Waiting for monitor entry</code>”，而在 “<code>Wait Set</code>” 中等待的线程状态是 “<code>in Object.wait()</code>”。</li></ul><p><img src="https://i.loli.net/2021/03/12/7GIk8J5qvMQYjDV.png" alt="0.png"></p><h4 id="案例二：Waiting-on-condition-和-TIMED-WAITING"><a href="#案例二：Waiting-on-condition-和-TIMED-WAITING" class="headerlink" title="案例二：Waiting on condition 和 TIMED_WAITING"></a>案例二：Waiting on condition 和 TIMED_WAITING</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;RMI TCP Connection(idle)&quot; daemon prio=10 tid=0x00007fd50834e800 nid=0x56b2 waiting on condition [0x00007fd4f1a59000]</span><br><span class="line">  java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait for &lt;0x00000000acd84de8&gt; (a java.util.concurrent.SynchronousQueue$TransferStack)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:198)</span><br><span class="line">at java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:424)</span><br><span class="line">at java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:323)</span><br><span class="line">at java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:874)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:945)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)</span><br><span class="line">at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure><p>1）“<code>TIMED_WAITING (parking)</code>” 中的<code>timed_waiting</code>指等待状态，但这里指定了时间，到达指定的时间后自动退出等待状态；<code>parking</code>指线程处于挂起中。</p><p>2）“<code>waiting on condition</code>” 需要与堆栈中的 “<code>parking to wait for  &lt;0x00000000acd84de8&gt; (a java.util.concurrent.SynchronousQueue$TransferStack)</code>” 结合来看。首先，本线程肯定是在等待某个条件的发生，来把自己唤醒。其次，<code>SynchronousQueue</code>并不是一个队列，只是线程之间移交信息的机制，当我们把一个元素放入到<code>SynchronousQueue</code>中时必须有另一个线程正在等待接受移交的任务，因此这就是本线程在等待的条件。</p><p>3）其他也看不出来什么。</p><h4 id="案例三：in-Obejct-wait-和-TIMED-WAITING"><a href="#案例三：in-Obejct-wait-和-TIMED-WAITING" class="headerlink" title="案例三：in Obejct.wait() 和 TIMED_WAITING"></a>案例三：in Obejct.wait() 和 TIMED_WAITING</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;RMI RenewClean-[172.16.7.19:28475]&quot; daemon prio=10 tid=0x0000000041428800 nid=0xb09 in Object.wait() [0x00007f34f4bd0000]</span><br><span class="line">  java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;0x00000000aa672478&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:118)</span><br><span class="line">- locked &lt;0x00000000aa672478&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">at sun.rmi.transport.DGCClient$EndpointEntry$RenewCleanThread.run(DGCClient.java:516)</span><br><span class="line">at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure><p>1）“<code>TIMED_WAITING (on object monitor)</code>”，对于本例而言，是因为本线程调用了<code>java.lang.Object.wait(long timeout)</code>而进入等待状态。</p><p>2）“<code>Wait Set</code>” 中等待的线程状态就是“<code>in Object.wait()</code>”。当线程获得了<code>Monitor</code>，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（一般就是被<code>synchronized</code>的对象）的<code>wait()</code>方法，放弃了<code>Monitor</code>，进入 “<code>Wait Set</code>” 队列。只有当别的线程在该对象上调用了<code>notify()</code>或者<code>notifyAll()</code>，“<code>Wait Set</code>” 队列中线程才得到机会去竞争，但是只有一个线程获得对象的<code>Monitor</code>，恢复到运行态。</p><p>3）<code>RMI RenewClean</code>是<code>DGCClient</code>的一部分。<code>DGC</code>指的是<code>Distributed GC</code>，即分布式垃圾回收。</p><p>4）请注意，是先<code>locked &lt;0x00000000aa672478&gt;</code>，后<code>waiting on &lt;0x00000000aa672478&gt;</code>，之所以先锁再等同一个对象，请看下面它的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">class</span>  <span class="title class_">Lock</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>();</span><br><span class="line"><span class="keyword">public</span> Reference&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; remove(<span class="type">long</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        Reference&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; r = reallyPoll();</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="literal">null</span>) <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            lock.wait(timeout);</span><br><span class="line">            r = reallyPoll();</span><br><span class="line">            ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即线程执行过程中，先用<code>synchronized</code>获得了这个对象的<code>Monitor</code>（对应于<code>locked &lt;0x00000000aa672478&gt;</code>）；当执行到<code>lock.wait(timeout);</code>，线程就放弃了<code>Monitor</code>的所有权，进入 “<code>Wait Set</code>” 队列（对应于<code>waiting on &lt;0x00000000aa672478&gt;</code>）。</p><p>5）从堆栈信息看，是正在清理<code>remote references to remote objects</code>，引用的租约到了，分布式垃圾回收在逐一清理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Thread-Dump日志分析案例&quot;&gt;&lt;a href=&quot;#Thread-Dump日志分析案例&quot; class=&quot;headerlink&quot; title=&quot;Thread Dump日志分析案例&quot;&gt;&lt;/a&gt;Thread Dump日志分析案例&lt;/h1&gt;&lt;h2 id=&quot;线程状态&quot;</summary>
      
    
    
    
    <category term="jvm" scheme="https://imalan6.github.io/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://imalan6.github.io/tags/jvm/"/>
    
    <category term="故障排查" scheme="https://imalan6.github.io/tags/%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github搭建个人博客</title>
    <link href="https://imalan6.github.io/2021/01/06/blog/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://imalan6.github.io/2021/01/06/blog/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-01-06T15:23:21.000Z</published>
    <updated>2024-02-17T06:23:31.666Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、创建博客项目"><a href="#一、创建博客项目" class="headerlink" title="一、创建博客项目"></a>一、创建博客项目</h3><p>1.1 准备工作</p><ul><li>下载<a href="http://nodejs.cn/download/">node.js</a>并安装（官网下载安装），默认会安装npm。</li><li>下载安装git（官网下载安装）</li><li>下载安装hexo，打开终端 运行<code>npm install -g hexo-cli</code></li></ul><p>1.2 初始化项目</p><ul><li><p>创建一个hexo-blog并初始化<br><code>hexo init hexo-blog</code></p></li><li><p>运行博客项目，查看生成的文章。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g  # 生成静态文件</span><br><span class="line">$ hexo s  # 运行本地web服务器</span><br></pre></td></tr></table></figure><p>访问地址：<a href="http://localhost:4000/">http://localhost:4000</a></p><h3 id="二、安装博客主题"><a href="#二、安装博客主题" class="headerlink" title="二、安装博客主题"></a>二、安装博客主题</h3><p>1、hexo可以选择不同的主题风格安装，这款叫pure还不错，看起比较干净清爽，</p><p>地址：<a href="https://github.com/cofess/hexo-theme-pure">https://github.com/cofess/hexo-theme-pure</a></p><p>安装命令：<code>npm install --save hexo-theme-pure</code></p><p>2、hexo配置以及使用</p><p>有两个配置文件：</p><ul><li>一个是根目录下的<code>_config.yml</code>称为<code>站点配置</code>文件</li><li>一个是<code>themes/pure/_config.yml</code>称为<code>主题配置</code>文件</li></ul><p>站点配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">url: https://yourname.github.io/&lt;repository,如果有的话&gt;</span><br><span class="line">theme: pure #选择想用的主题，我用的是pure</span><br><span class="line">deploy:</span><br><span class="line">    type: git # 不要使用github</span><br><span class="line">    repo: git@github.com:&lt;name&gt;/&lt;name&gt;.github.io.git/&lt;repository,如果有的话&gt; # 使用ssh连接</span><br><span class="line">    branch: master # 默认master分支</span><br><span class="line">    message: add new blog # 自动部署commit备注，可不填</span><br></pre></td></tr></table></figure><h3 id="三、配置github"><a href="#三、配置github" class="headerlink" title="三、配置github"></a>三、配置github</h3><p>新建仓库，仓库名必须为[your_name.github.io]，如果想安装在子目录，再创建一个仓库存放地址就是your_name.github.io&#x2F;repository</p><blockquote><p>补充：本地配置github ssh连接，方便自动部署，以及clone你喜欢的主题(theme)</p></blockquote><p>windows用户直接在<code>c:/用户/youername/.ssh/</code>下查看是否有<code>id_rsa.pub</code>文件。 没有的话命令行执行命令<code>ssh-keygen -t rsa -C &quot;your eamil&quot;</code>，会自动生成<code>id_rsa.pub</code>文件，打开后复制。</p><p>github仓库 —&gt; Settings —&gt; Deploy kyes→Add deploy key，粘贴复制的内容。</p><p>配置本地账户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name “your_username” #设置用户名</span><br><span class="line">git config --global user.email “your_email” #设置邮箱地址,最好使用注册邮箱地址</span><br></pre></td></tr></table></figure><p>测试是否配置成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h3 id="四、一键部署"><a href="#四、一键部署" class="headerlink" title="四、一键部署"></a>四、一键部署</h3><ol><li>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>。</li><li>在站点配置文件 <code>_config.yml</code> 中添加以下配置（如果配置已经存在，请将其替换为如下）:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/&lt;username&gt;/&lt;project&gt;</span><br><span class="line">  # example, https://github.com/hexojs/hexojs.github.io</span><br><span class="line">  branch: 代码分支，比如master</span><br></pre></td></tr></table></figure><ol><li>执行 <code>hexo clean &amp;&amp; hexo deploy</code>，代码自动上传部署 。</li><li>浏览 <code>&lt;GitHub 用户名&gt;.github.io</code> 检查网站是否运作正常。</li></ol><h3 id="附录：hexo常用命令"><a href="#附录：hexo常用命令" class="headerlink" title="附录：hexo常用命令"></a>附录：hexo常用命令</h3><p>hexo命令参考</p><p><code>hexo n &quot;我的博客&quot;</code> &#x3D;&#x3D; <code>hexo new &quot;我的博客&quot;</code> #新建文章<br><code>hexo p</code> &#x3D;&#x3D; <code>hexo publish</code><br><code>hexo g</code> &#x3D;&#x3D; <code>hexo generate</code> #生成<br><code>hexo s</code> &#x3D;&#x3D; <code>hexo server</code> #启动服务本地预览<br><code>hexo d</code> &#x3D;&#x3D; <code>hexo deploy</code> #部署<br><code>hexo clean</code> #清除缓存 网页正常情况下可以忽略此条命令</p><p><code>hexo server</code> #Hexo 会监视文件变动并自动更新，您无须重启服务器。<br><code>hexo server -s</code> #静态模式<br><code>hexo server -p 5000</code> #更改端口<br><code>hexo server -i 192.168.1.1</code> #自定义 IP</p><p>在执行之前，记得安装自动部署 (–save 加不加的区别在于是否写入到依赖文件package.json中)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>正常本地预览，直接执行<code>hexo s</code>,如果要发布话最好执行<code>clean</code>命令，会去删除生成的public文件，完整部署命令:<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>。或者直接<code>hexo d -g</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、创建博客项目&quot;&gt;&lt;a href=&quot;#一、创建博客项目&quot; class=&quot;headerlink&quot; title=&quot;一、创建博客项目&quot;&gt;&lt;/a&gt;一、创建博客项目&lt;/h3&gt;&lt;p&gt;1.1 准备工作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载&lt;a href=&quot;http://nodejs</summary>
      
    
    
    
    <category term="其他" scheme="https://imalan6.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="blog" scheme="https://imalan6.github.io/tags/blog/"/>
    
    <category term="hexo" scheme="https://imalan6.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>生产环境CPU 100%解决思路</title>
    <link href="https://imalan6.github.io/2020/12/16/jvm/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83CPU100%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/"/>
    <id>https://imalan6.github.io/2020/12/16/jvm/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83CPU100%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/</id>
    <published>2020-12-16T14:16:52.000Z</published>
    <updated>2024-02-14T12:04:57.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生产环境CPU-100-解决思路"><a href="#生产环境CPU-100-解决思路" class="headerlink" title="生产环境CPU 100%解决思路"></a>生产环境CPU 100%解决思路</h1><h2 id="排查方案"><a href="#排查方案" class="headerlink" title="排查方案"></a>排查方案</h2><p>如果服务器上部署了若干个Java服务，突然CPU异常告警。定位问题简要步骤如下：</p><p>1）找到最耗 CPU 的进程；</p><p>2）找到最耗 CPU 的线程；</p><p>3）查看堆栈信息，分析线程状态，定位问题代码；</p><p>一般来说，有必要在第1步找到问题进程后先使用<code>jstack</code>工具<code>dump</code>出堆栈日志。如果服务很重要，可以先考虑重启服务，保证线上服务的可用性，后面慢慢分析堆栈日志，找出问题。</p><h2 id="查看耗时进程"><a href="#查看耗时进程" class="headerlink" title="查看耗时进程"></a>查看耗时进程</h2><p>执行<code>top</code>命令，查看 CPU 占用率最高的进程，找出进程 ID。</p><p><img src="https://i.loli.net/2021/03/12/E7DUY3xlcfISbOr.jpg" alt="0.jpg"></p><h2 id="查看耗时线程"><a href="#查看耗时线程" class="headerlink" title="查看耗时线程"></a>查看耗时线程</h2><p>使用<code>top -Hp &lt;pid&gt;</code>命令，找出进程中最耗CPU的线程，并获得线程ID。</p><p><img src="https://i.loli.net/2021/03/12/UC8TzJP6ZWG3QK4.jpg" alt="1.jpg"></p><h2 id="查看线程堆栈"><a href="#查看线程堆栈" class="headerlink" title="查看线程堆栈"></a>查看线程堆栈</h2><p>由于获得的线程id是十进制形式的，而在堆栈日志中，线程id是十六进制的，所以可以使用命令<code>printf &quot;%x\n&quot; 10804</code>（也可以使用计算器），将十进制转换为十六进制，方便查找。得到 10804 对应的十六进制是<code>0x2a34</code>。</p><p>接着，使用命令<code>jstack 10765 | grep &#39;0x2a34&#39; -C5 --color</code>查看线程堆栈信息。当然，也可以使用<code>jstack 10765 &gt; dump.log</code>命令将堆栈日志保存下来离线分析。</p><p><img src="https://i.loli.net/2021/03/12/yP1nkTQeqwjt6gD.jpg" alt="3.jpg"></p><p>如上图，找到了耗CPU高的线程对应的线程名称 “<code>AsyncLogger-1</code>”，以及看到了该线程正在执行代码的堆栈。</p><h2 id="Thread-Dump日志分析"><a href="#Thread-Dump日志分析" class="headerlink" title="Thread Dump日志分析"></a>Thread Dump日志分析</h2><p>在<code>thread dump</code>文件里，需要关注的线程状态有：</p><ul><li><p>死锁，<code>Deadlock</code>（<strong>重点关注</strong>）</p></li><li><p>执行中，<code>Runnable</code></p></li><li><p>等待资源，<code>Waiting on condition</code>（<strong>重点关注</strong>）</p></li><li><p>等待获取监视器，<code>Waiting on monitor entry</code>（<strong>重点关注</strong>）</p></li><li><p>暂停，<code>Suspended</code></p></li><li><p>对象等待中，<code>Object.wait()</code>或<code>TIMED_WAITING</code></p></li><li><p>阻塞，<code>Blocked</code>（<strong>重点关注</strong>）</p></li><li><p>停止，<code>Parked</code></p></li></ul><p>保存的日志已经可以直接分析了，但是不是很直观，可以使用其他工具：</p><ul><li><p><code>Thread Dump Analyzer</code>工具<code>TDA</code>（下载地址：<a href="https://github.com/irockel/tda/%EF%BC%89">https://github.com/irockel/tda/）</a></p></li><li><p>在线分析工具：<a href="http://spotify.github.io/threaddump-analyzer/">http://spotify.github.io/threaddump-analyzer/</a></p></li></ul><p><code>ThreadDump</code>日志分析案例详见 <a href="jvm/ThreadDump%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B.md">Thread Dump日志分析案例</a>。</p><h2 id="JVM常见线程总结"><a href="#JVM常见线程总结" class="headerlink" title="JVM常见线程总结"></a>JVM常见线程总结</h2><table><thead><tr><th>线程名称</th><th>所属</th><th>解释说明</th></tr></thead><tbody><tr><td>Attach Listener</td><td>JVM</td><td>Attach Listener 线程是负责接收到外部的命令，而对该命令进行执行的并且吧结果返回给发送者。通常我们会用一些命令去要求 jvm 给我们一些反馈信息，如：java -version、jmap、jstack 等等。 如果该线程在 jvm 启动的时候没有初始化，那么，则会在用户第一次执行 jvm 命令时，得到启动。</td></tr><tr><td>Signal Dispatcher</td><td>JVM</td><td>前面我们提到第一个 Attach Listener 线程的职责是接收外部 jvm 命令，当命令接收成功后，会交给 signal dispather 线程去进行分发到各个不同的模块处理命令，并且返回处理结果。 signal dispather 线程也是在第一次接收外部 jvm 命令时，进行初始化工作。</td></tr><tr><td>CompilerThread0</td><td>JVM</td><td>用来调用JITing，实时编译装卸class 。 通常，jvm会启动多个线程来处理这部分工作，线程名称后面的数字也会累加，例如：CompilerThread1</td></tr><tr><td>Concurrent Mark-Sweep GC Thread</td><td>JVM</td><td>并发标记清除垃圾回收器（就是通常所说的CMS GC）线程， 该线程主要针对于老年代垃圾回收。ps：启用该垃圾回收器，需要在jvm启动参数中加上： -XX:+UseConcMarkSweepGC</td></tr><tr><td>DestroyJavaVM</td><td>JVM</td><td>执行 main() 的线程在 main 执行完后调用 JNI中 的 jni_DestroyJavaVM() 方法唤起DestroyJavaVM 线程。  JVM在 Jboss 服务器启动之后，就会唤起DestroyJavaVM线程，处于等待状态，等待其它线程（java线程和native线程）退出时通知它卸载JVM。</td></tr><tr><td>ContainerBackgroundProcessor 线程</td><td>JBOSS</td><td>它是一个守护线程, 在jboss服务器在启动的时候就初始化了,主要工作是定期去检查有没有Session过期.过期则清除</td></tr><tr><td>Dispatcher-Thread-3 线程</td><td>Log4j</td><td>Log4j 具有异步打印日志的功能，需要异步打印日志的 Appender 都需要注册到  AsyncAppender 对象里面去，由 AsyncAppender 进行监听，决定何时触发日志打印操作。</td></tr><tr><td>Finalizer 线程</td><td>JVM</td><td>这个线程也是在main线程之后创建的，其优先级为10，主要用于在垃圾收集前，调用对象的 finalize() 方法</td></tr><tr><td>Gang worker#0</td><td>JVM</td><td>JVM 用于做新生代垃圾回收（monir gc）的一个线程。#号后面是线程编号，例如：Gang worker#1</td></tr><tr><td>GC Daemon</td><td>JVM</td><td>GC Daemon 线程是 JVM 为 RMI 提供远程分布式 GC 使用的，GC Daemon 线程里面会主动调用System.gc() 方法，对服务器进行Full GC。</td></tr><tr><td>IdleRemover</td><td>JBOSS</td><td>Jboss连接池有一个最小值， 该线程每过一段时间都会被Jboss唤起，用于检查和销毁连接池中空闲和无效的连接，直到剩余的连接数小于等于它的最小值。</td></tr><tr><td>Java2D Disposer</td><td>JVM</td><td>这个线程主要服务于 awt 的各个组件。</td></tr><tr><td>InsttoolCacheScheduler_QuartzSchedulerThread</td><td>Quartz</td><td>InsttoolCacheScheduler_QuartzSchedulerThread 是 Quartz 的主线程，它主要负责实时的获取下一个时间点要触发的触发器，然后执行触发器相关联的作业 。</td></tr><tr><td>InsttoolCacheScheduler_Worker-2</td><td>Quartz</td><td>InsttoolCacheScheduler_Worker-2线程就是ThreadPool线程的一个简单实现，它主要负责分配线程资源去执行InsttoolCacheScheduler_QuartzSchedulerThread线程交给它的调度任务（也就是JobRunShell）。</td></tr><tr><td>JBossLifeThread</td><td>Jboss</td><td>Jboss主线程启动成功，应用程序部署完毕之后将JBossLifeThread线程实例化并且start，JBossLifeThread线程启动成功之后就处于等待状态，以保持Jboss Java进程处于存活中。 所得比较通俗一点，就是Jboss启动流程执行完毕之后，为什么没有结束？ 就是因为有这个线程hold主了它。 牛b吧～～</td></tr><tr><td>JBoss System Threads(1)-1</td><td>Jboss</td><td>该线程是一个socket服务，默认端口号为： 1099。 主要用于接收外部naming service（Jboss JNDI）请求。</td></tr><tr><td>JCA PoolFiller</td><td>Jboss</td><td>该线程主要为JBoss内部提供连接池的托管。</td></tr><tr><td>JDWP Event Helper Thread</td><td>JVM</td><td>JDWP是通讯交互协议，它定义了调试器和被调试程序之间传递信息的格式。它详细完整地定义了请求命令、回应数据和错误代码，保证了前端和后端的JVMTI和JDI的通信通畅。  该线程主要负责将JDI事件映射成JVMTI信号，以达到调试过程中操作JVM的目的。</td></tr><tr><td>JDWP Transport Listener: dt_socket</td><td>JVM</td><td>该线程是一个Java Debugger的监听器线程，负责受理客户端的debug请求。 通常我们习惯将它的监听端口设置为8787。</td></tr><tr><td>Low Memory Detector</td><td>JVM</td><td>这个线程是负责对可使用内存进行检测，如果发现可用内存低，分配新的内存空间。</td></tr><tr><td>process reaper</td><td>JVM</td><td>该线程负责去执行一个 OS 命令行的操作。</td></tr><tr><td>Reference Handler</td><td>JVM</td><td>JVM在创建main线程后就创建Reference Handler线程，其优先级最高，为10，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题 。</td></tr><tr><td>Surrogate Locker Thread (CMS)</td><td>JVM</td><td>这个线程主要用于配合CMS垃圾回收器使用，它是一个守护线程，其主要负责处理GC过程中，Java层的Reference（指软引用、弱引用等等）与jvm 内部层面的对象状态同步。</td></tr><tr><td>taskObjectTimerFactory</td><td>JVM</td><td>顾名思义，该线程就是用来执行任务的。 当我们把一个认为交给Timer对象，并且告诉它执行时间，周期时间后，Timer就会将该任务放入任务列队，并且通知taskObjectTimerFactory线程去处理任务，taskObjectTimerFactory线程会将状态为取消的任务从任务列队中移除，如果任务是非重复执行类型的，则在执行完该任务后，将它从任务列队中移除，如果该任务是需要重复执行的，则计算出它下一次执行的时间点。</td></tr><tr><td>VM Periodic Task Thread</td><td>JVM</td><td>该线程是 JVM 周期性任务调度的线程，它由 WatcherThread 创建，是一个单例对象。 该线程在 JVM 内使用得比较频繁，比如：定期的内存监控、JVM 运行状况监控，还有经常需要去执行一些 jstat 这类命令查看gc的情况，如下：jstat -gcutil 23483 250 7  这个命令告诉jvm 在控制台打印 PID 为：23483 的 gc 情况，间隔250毫秒打印一次，一共打印7次。</td></tr><tr><td>VM Thread</td><td>JVM</td><td>这个线程是jvm里面的线程母体，根据hotspot 源码（vmThread.cpp）里面的注释，它是一个单例的对象（最原始的线程）会产生或触发所有其他的线程，这个单个的VM线程是会被其他线程所使用来做一些 VM 操作（如，清扫垃圾等）。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生产环境CPU-100-解决思路&quot;&gt;&lt;a href=&quot;#生产环境CPU-100-解决思路&quot; class=&quot;headerlink&quot; title=&quot;生产环境CPU 100%解决思路&quot;&gt;&lt;/a&gt;生产环境CPU 100%解决思路&lt;/h1&gt;&lt;h2 id=&quot;排查方案&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="jvm" scheme="https://imalan6.github.io/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://imalan6.github.io/tags/jvm/"/>
    
    <category term="故障排查" scheme="https://imalan6.github.io/tags/%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"/>
    
  </entry>
  
</feed>
